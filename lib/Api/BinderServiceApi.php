<?php
/**
 * BinderServiceApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Jelastic API docs
 *
 * lets developers to automate a set of actions required for application lifecycle and extend our platform functionality by combining with other services. Using our API you can programmatically create environments, deploy apps and perform other tasks that could be earlier accomplished only via Jelastic dashboard but not limited to them.  Jelastic API follows REST principles. REST API determines a set of functions which can be requested by a developer, who then receives a response. The interaction is performed via HTTP protocol. The advantage of such method is a wide extension of the HTTP protocol. That's why REST API can be used from almost any programming language.
 *
 * The version of the OpenAPI document: 8.0.2
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.2.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * BinderServiceApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class BinderServiceApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'environmentBinderRestAdddomainsPost' => [
            'application/x-www-form-urlencoded',
        ],
        'environmentBinderRestAddsslcertPost' => [
            'application/x-www-form-urlencoded',
        ],
        'environmentBinderRestAttachextipPost' => [
            'application/x-www-form-urlencoded',
        ],
        'environmentBinderRestBindextdomainPost' => [
            'application/x-www-form-urlencoded',
        ],
        'environmentBinderRestBindextdomainsPost' => [
            'application/x-www-form-urlencoded',
        ],
        'environmentBinderRestBindsslPost' => [
            'application/x-www-form-urlencoded',
        ],
        'environmentBinderRestBindsslcertPost' => [
            'application/x-www-form-urlencoded',
        ],
        'environmentBinderRestCheckdomainPost' => [
            'application/x-www-form-urlencoded',
        ],
        'environmentBinderRestCheckextdomainPost' => [
            'application/x-www-form-urlencoded',
        ],
        'environmentBinderRestDeletesslPost' => [
            'application/x-www-form-urlencoded',
        ],
        'environmentBinderRestDetachextipPost' => [
            'application/x-www-form-urlencoded',
        ],
        'environmentBinderRestDisablesslPost' => [
            'application/x-www-form-urlencoded',
        ],
        'environmentBinderRestEditsslcertPost' => [
            'application/x-www-form-urlencoded',
        ],
        'environmentBinderRestGetdomainsPost' => [
            'application/x-www-form-urlencoded',
        ],
        'environmentBinderRestGetextdomainsPost' => [
            'application/x-www-form-urlencoded',
        ],
        'environmentBinderRestGetsslPost' => [
            'application/x-www-form-urlencoded',
        ],
        'environmentBinderRestGetsslcertsPost' => [
            'application/x-www-form-urlencoded',
        ],
        'environmentBinderRestMoveextipsPost' => [
            'application/x-www-form-urlencoded',
        ],
        'environmentBinderRestRemovedomainsPost' => [
            'application/x-www-form-urlencoded',
        ],
        'environmentBinderRestRemoveextdomainPost' => [
            'application/x-www-form-urlencoded',
        ],
        'environmentBinderRestRemovesslPost' => [
            'application/x-www-form-urlencoded',
        ],
        'environmentBinderRestRemovesslcertsPost' => [
            'application/x-www-form-urlencoded',
        ],
        'environmentBinderRestSetextipcountPost' => [
            'application/x-www-form-urlencoded',
        ],
        'environmentBinderRestSwapextdomainsPost' => [
            'application/x-www-form-urlencoded',
        ],
        'environmentBinderRestSwapextipsPost' => [
            'application/x-www-form-urlencoded',
        ],
        'environmentBinderRestUnbindsslcertPost' => [
            'application/x-www-form-urlencoded',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation environmentBinderRestAdddomainsPost
     *
     * @param  string $envName envName (required)
     * @param  string $domains domains (required)
     * @param  bool $subdomain subdomain (optional)
     * @param  string $nodeGroup nodeGroup (optional)
     * @param  int $nodeId nodeId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestAdddomainsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ComHivextApiResponse
     */
    public function environmentBinderRestAdddomainsPost($envName, $domains, $subdomain = null, $nodeGroup = null, $nodeId = null, string $contentType = self::contentTypes['environmentBinderRestAdddomainsPost'][0])
    {
        list($response) = $this->environmentBinderRestAdddomainsPostWithHttpInfo($envName, $domains, $subdomain, $nodeGroup, $nodeId, $contentType);
        return $response;
    }

    /**
     * Operation environmentBinderRestAdddomainsPostWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  string $domains (required)
     * @param  bool $subdomain (optional)
     * @param  string $nodeGroup (optional)
     * @param  int $nodeId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestAdddomainsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ComHivextApiResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function environmentBinderRestAdddomainsPostWithHttpInfo($envName, $domains, $subdomain = null, $nodeGroup = null, $nodeId = null, string $contentType = self::contentTypes['environmentBinderRestAdddomainsPost'][0])
    {
        $request = $this->environmentBinderRestAdddomainsPostRequest($envName, $domains, $subdomain, $nodeGroup, $nodeId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ComHivextApiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ComHivextApiResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ComHivextApiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ComHivextApiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ComHivextApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation environmentBinderRestAdddomainsPostAsync
     *
     * @param  string $envName (required)
     * @param  string $domains (required)
     * @param  bool $subdomain (optional)
     * @param  string $nodeGroup (optional)
     * @param  int $nodeId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestAdddomainsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestAdddomainsPostAsync($envName, $domains, $subdomain = null, $nodeGroup = null, $nodeId = null, string $contentType = self::contentTypes['environmentBinderRestAdddomainsPost'][0])
    {
        return $this->environmentBinderRestAdddomainsPostAsyncWithHttpInfo($envName, $domains, $subdomain, $nodeGroup, $nodeId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation environmentBinderRestAdddomainsPostAsyncWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  string $domains (required)
     * @param  bool $subdomain (optional)
     * @param  string $nodeGroup (optional)
     * @param  int $nodeId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestAdddomainsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestAdddomainsPostAsyncWithHttpInfo($envName, $domains, $subdomain = null, $nodeGroup = null, $nodeId = null, string $contentType = self::contentTypes['environmentBinderRestAdddomainsPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ComHivextApiResponse';
        $request = $this->environmentBinderRestAdddomainsPostRequest($envName, $domains, $subdomain, $nodeGroup, $nodeId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'environmentBinderRestAdddomainsPost'
     *
     * @param  string $envName (required)
     * @param  string $domains (required)
     * @param  bool $subdomain (optional)
     * @param  string $nodeGroup (optional)
     * @param  int $nodeId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestAdddomainsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function environmentBinderRestAdddomainsPostRequest($envName, $domains, $subdomain = null, $nodeGroup = null, $nodeId = null, string $contentType = self::contentTypes['environmentBinderRestAdddomainsPost'][0])
    {

        // verify the required parameter 'envName' is set
        if ($envName === null || (is_array($envName) && count($envName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envName when calling environmentBinderRestAdddomainsPost'
            );
        }
        if (strlen($envName) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$envName" when calling BinderServiceApi.environmentBinderRestAdddomainsPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $envName)) {
            throw new \InvalidArgumentException("invalid value for \"envName\" when calling BinderServiceApi.environmentBinderRestAdddomainsPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        // verify the required parameter 'domains' is set
        if ($domains === null || (is_array($domains) && count($domains) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domains when calling environmentBinderRestAdddomainsPost'
            );
        }
        if (strlen($domains) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$domains" when calling BinderServiceApi.environmentBinderRestAdddomainsPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $domains)) {
            throw new \InvalidArgumentException("invalid value for \"domains\" when calling BinderServiceApi.environmentBinderRestAdddomainsPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        

        if ($nodeGroup !== null && strlen($nodeGroup) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$nodeGroup" when calling BinderServiceApi.environmentBinderRestAdddomainsPost, must be smaller than or equal to 2147483647.');
        }
        if ($nodeGroup !== null && !preg_match("/(.*){0,2147483647}/", $nodeGroup)) {
            throw new \InvalidArgumentException("invalid value for \"nodeGroup\" when calling BinderServiceApi.environmentBinderRestAdddomainsPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        if ($nodeId !== null && $nodeId > 2147483647) {
            throw new \InvalidArgumentException('invalid value for "$nodeId" when calling BinderServiceApi.environmentBinderRestAdddomainsPost, must be smaller than or equal to 2147483647.');
        }
        if ($nodeId !== null && $nodeId < -2147483648) {
            throw new \InvalidArgumentException('invalid value for "$nodeId" when calling BinderServiceApi.environmentBinderRestAdddomainsPost, must be bigger than or equal to -2147483648.');
        }
        

        $resourcePath = '/environment/binder/rest/adddomains';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($envName !== null) {
            $formParams['envName'] = ObjectSerializer::toFormValue($envName);
        }
        // form params
        if ($domains !== null) {
            $formParams['domains'] = ObjectSerializer::toFormValue($domains);
        }
        // form params
        if ($subdomain !== null) {
            $formParams['subdomain'] = ObjectSerializer::toFormValue($subdomain);
        }
        // form params
        if ($nodeGroup !== null) {
            $formParams['nodeGroup'] = ObjectSerializer::toFormValue($nodeGroup);
        }
        // form params
        if ($nodeId !== null) {
            $formParams['nodeId'] = ObjectSerializer::toFormValue($nodeId);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation environmentBinderRestAddsslcertPost
     *
     * @param  string $cert cert (required)
     * @param  string $key key (required)
     * @param  string $interm interm (optional)
     * @param  string $envName envName (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestAddsslcertPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCertResponse
     */
    public function environmentBinderRestAddsslcertPost($cert, $key, $interm = null, $envName = null, string $contentType = self::contentTypes['environmentBinderRestAddsslcertPost'][0])
    {
        list($response) = $this->environmentBinderRestAddsslcertPostWithHttpInfo($cert, $key, $interm, $envName, $contentType);
        return $response;
    }

    /**
     * Operation environmentBinderRestAddsslcertPostWithHttpInfo
     *
     * @param  string $cert (required)
     * @param  string $key (required)
     * @param  string $interm (optional)
     * @param  string $envName (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestAddsslcertPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCertResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function environmentBinderRestAddsslcertPostWithHttpInfo($cert, $key, $interm = null, $envName = null, string $contentType = self::contentTypes['environmentBinderRestAddsslcertPost'][0])
    {
        $request = $this->environmentBinderRestAddsslcertPostRequest($cert, $key, $interm, $envName, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCertResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCertResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCertResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCertResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCertResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation environmentBinderRestAddsslcertPostAsync
     *
     * @param  string $cert (required)
     * @param  string $key (required)
     * @param  string $interm (optional)
     * @param  string $envName (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestAddsslcertPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestAddsslcertPostAsync($cert, $key, $interm = null, $envName = null, string $contentType = self::contentTypes['environmentBinderRestAddsslcertPost'][0])
    {
        return $this->environmentBinderRestAddsslcertPostAsyncWithHttpInfo($cert, $key, $interm, $envName, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation environmentBinderRestAddsslcertPostAsyncWithHttpInfo
     *
     * @param  string $cert (required)
     * @param  string $key (required)
     * @param  string $interm (optional)
     * @param  string $envName (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestAddsslcertPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestAddsslcertPostAsyncWithHttpInfo($cert, $key, $interm = null, $envName = null, string $contentType = self::contentTypes['environmentBinderRestAddsslcertPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCertResponse';
        $request = $this->environmentBinderRestAddsslcertPostRequest($cert, $key, $interm, $envName, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'environmentBinderRestAddsslcertPost'
     *
     * @param  string $cert (required)
     * @param  string $key (required)
     * @param  string $interm (optional)
     * @param  string $envName (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestAddsslcertPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function environmentBinderRestAddsslcertPostRequest($cert, $key, $interm = null, $envName = null, string $contentType = self::contentTypes['environmentBinderRestAddsslcertPost'][0])
    {

        // verify the required parameter 'cert' is set
        if ($cert === null || (is_array($cert) && count($cert) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cert when calling environmentBinderRestAddsslcertPost'
            );
        }
        if (strlen($cert) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$cert" when calling BinderServiceApi.environmentBinderRestAddsslcertPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $cert)) {
            throw new \InvalidArgumentException("invalid value for \"cert\" when calling BinderServiceApi.environmentBinderRestAddsslcertPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling environmentBinderRestAddsslcertPost'
            );
        }
        if (strlen($key) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$key" when calling BinderServiceApi.environmentBinderRestAddsslcertPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $key)) {
            throw new \InvalidArgumentException("invalid value for \"key\" when calling BinderServiceApi.environmentBinderRestAddsslcertPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        if ($interm !== null && strlen($interm) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$interm" when calling BinderServiceApi.environmentBinderRestAddsslcertPost, must be smaller than or equal to 2147483647.');
        }
        if ($interm !== null && !preg_match("/(.*){0,2147483647}/", $interm)) {
            throw new \InvalidArgumentException("invalid value for \"interm\" when calling BinderServiceApi.environmentBinderRestAddsslcertPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        if ($envName !== null && strlen($envName) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$envName" when calling BinderServiceApi.environmentBinderRestAddsslcertPost, must be smaller than or equal to 2147483647.');
        }
        if ($envName !== null && !preg_match("/(.*){0,2147483647}/", $envName)) {
            throw new \InvalidArgumentException("invalid value for \"envName\" when calling BinderServiceApi.environmentBinderRestAddsslcertPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        

        $resourcePath = '/environment/binder/rest/addsslcert';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($interm !== null) {
            $formParams['interm'] = ObjectSerializer::toFormValue($interm);
        }
        // form params
        if ($envName !== null) {
            $formParams['envName'] = ObjectSerializer::toFormValue($envName);
        }
        // form params
        if ($cert !== null) {
            $formParams['cert'] = ObjectSerializer::toFormValue($cert);
        }
        // form params
        if ($key !== null) {
            $formParams['key'] = ObjectSerializer::toFormValue($key);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation environmentBinderRestAttachextipPost
     *
     * @param  string $envName envName (required)
     * @param  int $nodeid nodeid (required)
     * @param  string $type type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestAttachextipPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseObjectResponse
     */
    public function environmentBinderRestAttachextipPost($envName, $nodeid, $type = null, string $contentType = self::contentTypes['environmentBinderRestAttachextipPost'][0])
    {
        list($response) = $this->environmentBinderRestAttachextipPostWithHttpInfo($envName, $nodeid, $type, $contentType);
        return $response;
    }

    /**
     * Operation environmentBinderRestAttachextipPostWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  int $nodeid (required)
     * @param  string $type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestAttachextipPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseObjectResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function environmentBinderRestAttachextipPostWithHttpInfo($envName, $nodeid, $type = null, string $contentType = self::contentTypes['environmentBinderRestAttachextipPost'][0])
    {
        $request = $this->environmentBinderRestAttachextipPostRequest($envName, $nodeid, $type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseObjectResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseObjectResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseObjectResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseObjectResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseObjectResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation environmentBinderRestAttachextipPostAsync
     *
     * @param  string $envName (required)
     * @param  int $nodeid (required)
     * @param  string $type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestAttachextipPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestAttachextipPostAsync($envName, $nodeid, $type = null, string $contentType = self::contentTypes['environmentBinderRestAttachextipPost'][0])
    {
        return $this->environmentBinderRestAttachextipPostAsyncWithHttpInfo($envName, $nodeid, $type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation environmentBinderRestAttachextipPostAsyncWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  int $nodeid (required)
     * @param  string $type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestAttachextipPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestAttachextipPostAsyncWithHttpInfo($envName, $nodeid, $type = null, string $contentType = self::contentTypes['environmentBinderRestAttachextipPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseObjectResponse';
        $request = $this->environmentBinderRestAttachextipPostRequest($envName, $nodeid, $type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'environmentBinderRestAttachextipPost'
     *
     * @param  string $envName (required)
     * @param  int $nodeid (required)
     * @param  string $type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestAttachextipPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function environmentBinderRestAttachextipPostRequest($envName, $nodeid, $type = null, string $contentType = self::contentTypes['environmentBinderRestAttachextipPost'][0])
    {

        // verify the required parameter 'envName' is set
        if ($envName === null || (is_array($envName) && count($envName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envName when calling environmentBinderRestAttachextipPost'
            );
        }
        if (strlen($envName) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$envName" when calling BinderServiceApi.environmentBinderRestAttachextipPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $envName)) {
            throw new \InvalidArgumentException("invalid value for \"envName\" when calling BinderServiceApi.environmentBinderRestAttachextipPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        // verify the required parameter 'nodeid' is set
        if ($nodeid === null || (is_array($nodeid) && count($nodeid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $nodeid when calling environmentBinderRestAttachextipPost'
            );
        }
        if ($nodeid > 2147483647) {
            throw new \InvalidArgumentException('invalid value for "$nodeid" when calling BinderServiceApi.environmentBinderRestAttachextipPost, must be smaller than or equal to 2147483647.');
        }
        if ($nodeid < -2147483648) {
            throw new \InvalidArgumentException('invalid value for "$nodeid" when calling BinderServiceApi.environmentBinderRestAttachextipPost, must be bigger than or equal to -2147483648.');
        }
        
        if ($type !== null && strlen($type) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$type" when calling BinderServiceApi.environmentBinderRestAttachextipPost, must be smaller than or equal to 2147483647.');
        }
        if ($type !== null && !preg_match("/(.*){0,2147483647}/", $type)) {
            throw new \InvalidArgumentException("invalid value for \"type\" when calling BinderServiceApi.environmentBinderRestAttachextipPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        

        $resourcePath = '/environment/binder/rest/attachextip';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($envName !== null) {
            $formParams['envName'] = ObjectSerializer::toFormValue($envName);
        }
        // form params
        if ($type !== null) {
            $formParams['type'] = ObjectSerializer::toFormValue($type);
        }
        // form params
        if ($nodeid !== null) {
            $formParams['nodeid'] = ObjectSerializer::toFormValue($nodeid);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation environmentBinderRestBindextdomainPost
     *
     * @param  string $envName envName (required)
     * @param  string $extdomain extdomain (required)
     * @param  int $certId certId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestBindextdomainPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseExtDomainResponse
     */
    public function environmentBinderRestBindextdomainPost($envName, $extdomain, $certId = null, string $contentType = self::contentTypes['environmentBinderRestBindextdomainPost'][0])
    {
        list($response) = $this->environmentBinderRestBindextdomainPostWithHttpInfo($envName, $extdomain, $certId, $contentType);
        return $response;
    }

    /**
     * Operation environmentBinderRestBindextdomainPostWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  string $extdomain (required)
     * @param  int $certId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestBindextdomainPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseExtDomainResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function environmentBinderRestBindextdomainPostWithHttpInfo($envName, $extdomain, $certId = null, string $contentType = self::contentTypes['environmentBinderRestBindextdomainPost'][0])
    {
        $request = $this->environmentBinderRestBindextdomainPostRequest($envName, $extdomain, $certId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseExtDomainResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseExtDomainResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseExtDomainResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseExtDomainResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseExtDomainResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation environmentBinderRestBindextdomainPostAsync
     *
     * @param  string $envName (required)
     * @param  string $extdomain (required)
     * @param  int $certId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestBindextdomainPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestBindextdomainPostAsync($envName, $extdomain, $certId = null, string $contentType = self::contentTypes['environmentBinderRestBindextdomainPost'][0])
    {
        return $this->environmentBinderRestBindextdomainPostAsyncWithHttpInfo($envName, $extdomain, $certId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation environmentBinderRestBindextdomainPostAsyncWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  string $extdomain (required)
     * @param  int $certId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestBindextdomainPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestBindextdomainPostAsyncWithHttpInfo($envName, $extdomain, $certId = null, string $contentType = self::contentTypes['environmentBinderRestBindextdomainPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseExtDomainResponse';
        $request = $this->environmentBinderRestBindextdomainPostRequest($envName, $extdomain, $certId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'environmentBinderRestBindextdomainPost'
     *
     * @param  string $envName (required)
     * @param  string $extdomain (required)
     * @param  int $certId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestBindextdomainPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function environmentBinderRestBindextdomainPostRequest($envName, $extdomain, $certId = null, string $contentType = self::contentTypes['environmentBinderRestBindextdomainPost'][0])
    {

        // verify the required parameter 'envName' is set
        if ($envName === null || (is_array($envName) && count($envName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envName when calling environmentBinderRestBindextdomainPost'
            );
        }
        if (strlen($envName) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$envName" when calling BinderServiceApi.environmentBinderRestBindextdomainPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $envName)) {
            throw new \InvalidArgumentException("invalid value for \"envName\" when calling BinderServiceApi.environmentBinderRestBindextdomainPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        // verify the required parameter 'extdomain' is set
        if ($extdomain === null || (is_array($extdomain) && count($extdomain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $extdomain when calling environmentBinderRestBindextdomainPost'
            );
        }
        if (strlen($extdomain) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$extdomain" when calling BinderServiceApi.environmentBinderRestBindextdomainPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $extdomain)) {
            throw new \InvalidArgumentException("invalid value for \"extdomain\" when calling BinderServiceApi.environmentBinderRestBindextdomainPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        if ($certId !== null && $certId > 2147483647) {
            throw new \InvalidArgumentException('invalid value for "$certId" when calling BinderServiceApi.environmentBinderRestBindextdomainPost, must be smaller than or equal to 2147483647.');
        }
        if ($certId !== null && $certId < -2147483648) {
            throw new \InvalidArgumentException('invalid value for "$certId" when calling BinderServiceApi.environmentBinderRestBindextdomainPost, must be bigger than or equal to -2147483648.');
        }
        

        $resourcePath = '/environment/binder/rest/bindextdomain';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($envName !== null) {
            $formParams['envName'] = ObjectSerializer::toFormValue($envName);
        }
        // form params
        if ($extdomain !== null) {
            $formParams['extdomain'] = ObjectSerializer::toFormValue($extdomain);
        }
        // form params
        if ($certId !== null) {
            $formParams['certId'] = ObjectSerializer::toFormValue($certId);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation environmentBinderRestBindextdomainsPost
     *
     * @param  string $envName envName (required)
     * @param  string $extDomains extDomains (required)
     * @param  int $certId certId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestBindextdomainsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseExtDomainResponses
     */
    public function environmentBinderRestBindextdomainsPost($envName, $extDomains, $certId = null, string $contentType = self::contentTypes['environmentBinderRestBindextdomainsPost'][0])
    {
        list($response) = $this->environmentBinderRestBindextdomainsPostWithHttpInfo($envName, $extDomains, $certId, $contentType);
        return $response;
    }

    /**
     * Operation environmentBinderRestBindextdomainsPostWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  string $extDomains (required)
     * @param  int $certId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestBindextdomainsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseExtDomainResponses, HTTP status code, HTTP response headers (array of strings)
     */
    public function environmentBinderRestBindextdomainsPostWithHttpInfo($envName, $extDomains, $certId = null, string $contentType = self::contentTypes['environmentBinderRestBindextdomainsPost'][0])
    {
        $request = $this->environmentBinderRestBindextdomainsPostRequest($envName, $extDomains, $certId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseExtDomainResponses' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseExtDomainResponses' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseExtDomainResponses', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseExtDomainResponses';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseExtDomainResponses',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation environmentBinderRestBindextdomainsPostAsync
     *
     * @param  string $envName (required)
     * @param  string $extDomains (required)
     * @param  int $certId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestBindextdomainsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestBindextdomainsPostAsync($envName, $extDomains, $certId = null, string $contentType = self::contentTypes['environmentBinderRestBindextdomainsPost'][0])
    {
        return $this->environmentBinderRestBindextdomainsPostAsyncWithHttpInfo($envName, $extDomains, $certId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation environmentBinderRestBindextdomainsPostAsyncWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  string $extDomains (required)
     * @param  int $certId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestBindextdomainsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestBindextdomainsPostAsyncWithHttpInfo($envName, $extDomains, $certId = null, string $contentType = self::contentTypes['environmentBinderRestBindextdomainsPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseExtDomainResponses';
        $request = $this->environmentBinderRestBindextdomainsPostRequest($envName, $extDomains, $certId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'environmentBinderRestBindextdomainsPost'
     *
     * @param  string $envName (required)
     * @param  string $extDomains (required)
     * @param  int $certId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestBindextdomainsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function environmentBinderRestBindextdomainsPostRequest($envName, $extDomains, $certId = null, string $contentType = self::contentTypes['environmentBinderRestBindextdomainsPost'][0])
    {

        // verify the required parameter 'envName' is set
        if ($envName === null || (is_array($envName) && count($envName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envName when calling environmentBinderRestBindextdomainsPost'
            );
        }
        if (strlen($envName) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$envName" when calling BinderServiceApi.environmentBinderRestBindextdomainsPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $envName)) {
            throw new \InvalidArgumentException("invalid value for \"envName\" when calling BinderServiceApi.environmentBinderRestBindextdomainsPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        // verify the required parameter 'extDomains' is set
        if ($extDomains === null || (is_array($extDomains) && count($extDomains) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $extDomains when calling environmentBinderRestBindextdomainsPost'
            );
        }
        if (strlen($extDomains) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$extDomains" when calling BinderServiceApi.environmentBinderRestBindextdomainsPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $extDomains)) {
            throw new \InvalidArgumentException("invalid value for \"extDomains\" when calling BinderServiceApi.environmentBinderRestBindextdomainsPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        if ($certId !== null && $certId > 2147483647) {
            throw new \InvalidArgumentException('invalid value for "$certId" when calling BinderServiceApi.environmentBinderRestBindextdomainsPost, must be smaller than or equal to 2147483647.');
        }
        if ($certId !== null && $certId < -2147483648) {
            throw new \InvalidArgumentException('invalid value for "$certId" when calling BinderServiceApi.environmentBinderRestBindextdomainsPost, must be bigger than or equal to -2147483648.');
        }
        

        $resourcePath = '/environment/binder/rest/bindextdomains';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($envName !== null) {
            $formParams['envName'] = ObjectSerializer::toFormValue($envName);
        }
        // form params
        if ($extDomains !== null) {
            $formParams['extDomains'] = ObjectSerializer::toFormValue($extDomains);
        }
        // form params
        if ($certId !== null) {
            $formParams['certId'] = ObjectSerializer::toFormValue($certId);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation environmentBinderRestBindsslPost
     *
     * @param  string $certKey certKey (required)
     * @param  string $envName envName (required)
     * @param  string $intermediate intermediate (required)
     * @param  string $cert cert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestBindsslPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCustomResponse
     */
    public function environmentBinderRestBindsslPost($certKey, $envName, $intermediate, $cert, string $contentType = self::contentTypes['environmentBinderRestBindsslPost'][0])
    {
        list($response) = $this->environmentBinderRestBindsslPostWithHttpInfo($certKey, $envName, $intermediate, $cert, $contentType);
        return $response;
    }

    /**
     * Operation environmentBinderRestBindsslPostWithHttpInfo
     *
     * @param  string $certKey (required)
     * @param  string $envName (required)
     * @param  string $intermediate (required)
     * @param  string $cert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestBindsslPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCustomResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function environmentBinderRestBindsslPostWithHttpInfo($certKey, $envName, $intermediate, $cert, string $contentType = self::contentTypes['environmentBinderRestBindsslPost'][0])
    {
        $request = $this->environmentBinderRestBindsslPostRequest($certKey, $envName, $intermediate, $cert, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCustomResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCustomResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCustomResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCustomResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCustomResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation environmentBinderRestBindsslPostAsync
     *
     * @param  string $certKey (required)
     * @param  string $envName (required)
     * @param  string $intermediate (required)
     * @param  string $cert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestBindsslPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestBindsslPostAsync($certKey, $envName, $intermediate, $cert, string $contentType = self::contentTypes['environmentBinderRestBindsslPost'][0])
    {
        return $this->environmentBinderRestBindsslPostAsyncWithHttpInfo($certKey, $envName, $intermediate, $cert, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation environmentBinderRestBindsslPostAsyncWithHttpInfo
     *
     * @param  string $certKey (required)
     * @param  string $envName (required)
     * @param  string $intermediate (required)
     * @param  string $cert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestBindsslPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestBindsslPostAsyncWithHttpInfo($certKey, $envName, $intermediate, $cert, string $contentType = self::contentTypes['environmentBinderRestBindsslPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCustomResponse';
        $request = $this->environmentBinderRestBindsslPostRequest($certKey, $envName, $intermediate, $cert, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'environmentBinderRestBindsslPost'
     *
     * @param  string $certKey (required)
     * @param  string $envName (required)
     * @param  string $intermediate (required)
     * @param  string $cert (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestBindsslPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function environmentBinderRestBindsslPostRequest($certKey, $envName, $intermediate, $cert, string $contentType = self::contentTypes['environmentBinderRestBindsslPost'][0])
    {

        // verify the required parameter 'certKey' is set
        if ($certKey === null || (is_array($certKey) && count($certKey) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $certKey when calling environmentBinderRestBindsslPost'
            );
        }
        if (strlen($certKey) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$certKey" when calling BinderServiceApi.environmentBinderRestBindsslPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $certKey)) {
            throw new \InvalidArgumentException("invalid value for \"certKey\" when calling BinderServiceApi.environmentBinderRestBindsslPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        // verify the required parameter 'envName' is set
        if ($envName === null || (is_array($envName) && count($envName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envName when calling environmentBinderRestBindsslPost'
            );
        }
        if (strlen($envName) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$envName" when calling BinderServiceApi.environmentBinderRestBindsslPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $envName)) {
            throw new \InvalidArgumentException("invalid value for \"envName\" when calling BinderServiceApi.environmentBinderRestBindsslPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        // verify the required parameter 'intermediate' is set
        if ($intermediate === null || (is_array($intermediate) && count($intermediate) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $intermediate when calling environmentBinderRestBindsslPost'
            );
        }
        if (strlen($intermediate) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$intermediate" when calling BinderServiceApi.environmentBinderRestBindsslPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $intermediate)) {
            throw new \InvalidArgumentException("invalid value for \"intermediate\" when calling BinderServiceApi.environmentBinderRestBindsslPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        // verify the required parameter 'cert' is set
        if ($cert === null || (is_array($cert) && count($cert) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cert when calling environmentBinderRestBindsslPost'
            );
        }
        if (strlen($cert) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$cert" when calling BinderServiceApi.environmentBinderRestBindsslPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $cert)) {
            throw new \InvalidArgumentException("invalid value for \"cert\" when calling BinderServiceApi.environmentBinderRestBindsslPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        

        $resourcePath = '/environment/binder/rest/bindssl';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($certKey !== null) {
            $formParams['cert_key'] = ObjectSerializer::toFormValue($certKey);
        }
        // form params
        if ($envName !== null) {
            $formParams['envName'] = ObjectSerializer::toFormValue($envName);
        }
        // form params
        if ($intermediate !== null) {
            $formParams['intermediate'] = ObjectSerializer::toFormValue($intermediate);
        }
        // form params
        if ($cert !== null) {
            $formParams['cert'] = ObjectSerializer::toFormValue($cert);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation environmentBinderRestBindsslcertPost
     *
     * @param  string $envName envName (required)
     * @param  int $certId certId (required)
     * @param  string $entryPoint entryPoint (optional)
     * @param  string $extDomains extDomains (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestBindsslcertPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ComHivextApiResponse
     */
    public function environmentBinderRestBindsslcertPost($envName, $certId, $entryPoint = null, $extDomains = null, string $contentType = self::contentTypes['environmentBinderRestBindsslcertPost'][0])
    {
        list($response) = $this->environmentBinderRestBindsslcertPostWithHttpInfo($envName, $certId, $entryPoint, $extDomains, $contentType);
        return $response;
    }

    /**
     * Operation environmentBinderRestBindsslcertPostWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  int $certId (required)
     * @param  string $entryPoint (optional)
     * @param  string $extDomains (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestBindsslcertPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ComHivextApiResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function environmentBinderRestBindsslcertPostWithHttpInfo($envName, $certId, $entryPoint = null, $extDomains = null, string $contentType = self::contentTypes['environmentBinderRestBindsslcertPost'][0])
    {
        $request = $this->environmentBinderRestBindsslcertPostRequest($envName, $certId, $entryPoint, $extDomains, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ComHivextApiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ComHivextApiResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ComHivextApiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ComHivextApiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ComHivextApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation environmentBinderRestBindsslcertPostAsync
     *
     * @param  string $envName (required)
     * @param  int $certId (required)
     * @param  string $entryPoint (optional)
     * @param  string $extDomains (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestBindsslcertPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestBindsslcertPostAsync($envName, $certId, $entryPoint = null, $extDomains = null, string $contentType = self::contentTypes['environmentBinderRestBindsslcertPost'][0])
    {
        return $this->environmentBinderRestBindsslcertPostAsyncWithHttpInfo($envName, $certId, $entryPoint, $extDomains, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation environmentBinderRestBindsslcertPostAsyncWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  int $certId (required)
     * @param  string $entryPoint (optional)
     * @param  string $extDomains (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestBindsslcertPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestBindsslcertPostAsyncWithHttpInfo($envName, $certId, $entryPoint = null, $extDomains = null, string $contentType = self::contentTypes['environmentBinderRestBindsslcertPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ComHivextApiResponse';
        $request = $this->environmentBinderRestBindsslcertPostRequest($envName, $certId, $entryPoint, $extDomains, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'environmentBinderRestBindsslcertPost'
     *
     * @param  string $envName (required)
     * @param  int $certId (required)
     * @param  string $entryPoint (optional)
     * @param  string $extDomains (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestBindsslcertPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function environmentBinderRestBindsslcertPostRequest($envName, $certId, $entryPoint = null, $extDomains = null, string $contentType = self::contentTypes['environmentBinderRestBindsslcertPost'][0])
    {

        // verify the required parameter 'envName' is set
        if ($envName === null || (is_array($envName) && count($envName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envName when calling environmentBinderRestBindsslcertPost'
            );
        }
        if (strlen($envName) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$envName" when calling BinderServiceApi.environmentBinderRestBindsslcertPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $envName)) {
            throw new \InvalidArgumentException("invalid value for \"envName\" when calling BinderServiceApi.environmentBinderRestBindsslcertPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        // verify the required parameter 'certId' is set
        if ($certId === null || (is_array($certId) && count($certId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $certId when calling environmentBinderRestBindsslcertPost'
            );
        }
        if ($certId > 2147483647) {
            throw new \InvalidArgumentException('invalid value for "$certId" when calling BinderServiceApi.environmentBinderRestBindsslcertPost, must be smaller than or equal to 2147483647.');
        }
        if ($certId < -2147483648) {
            throw new \InvalidArgumentException('invalid value for "$certId" when calling BinderServiceApi.environmentBinderRestBindsslcertPost, must be bigger than or equal to -2147483648.');
        }
        
        if ($entryPoint !== null && strlen($entryPoint) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$entryPoint" when calling BinderServiceApi.environmentBinderRestBindsslcertPost, must be smaller than or equal to 2147483647.');
        }
        if ($entryPoint !== null && !preg_match("/(.*){0,2147483647}/", $entryPoint)) {
            throw new \InvalidArgumentException("invalid value for \"entryPoint\" when calling BinderServiceApi.environmentBinderRestBindsslcertPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        if ($extDomains !== null && strlen($extDomains) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$extDomains" when calling BinderServiceApi.environmentBinderRestBindsslcertPost, must be smaller than or equal to 2147483647.');
        }
        if ($extDomains !== null && !preg_match("/(.*){0,2147483647}/", $extDomains)) {
            throw new \InvalidArgumentException("invalid value for \"extDomains\" when calling BinderServiceApi.environmentBinderRestBindsslcertPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        

        $resourcePath = '/environment/binder/rest/bindsslcert';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($envName !== null) {
            $formParams['envName'] = ObjectSerializer::toFormValue($envName);
        }
        // form params
        if ($certId !== null) {
            $formParams['certId'] = ObjectSerializer::toFormValue($certId);
        }
        // form params
        if ($entryPoint !== null) {
            $formParams['entryPoint'] = ObjectSerializer::toFormValue($entryPoint);
        }
        // form params
        if ($extDomains !== null) {
            $formParams['extDomains'] = ObjectSerializer::toFormValue($extDomains);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation environmentBinderRestCheckdomainPost
     *
     * @param  string $domain domain (required)
     * @param  string $region region (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestCheckdomainPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ComHivextApiResponse
     */
    public function environmentBinderRestCheckdomainPost($domain, $region = null, string $contentType = self::contentTypes['environmentBinderRestCheckdomainPost'][0])
    {
        list($response) = $this->environmentBinderRestCheckdomainPostWithHttpInfo($domain, $region, $contentType);
        return $response;
    }

    /**
     * Operation environmentBinderRestCheckdomainPostWithHttpInfo
     *
     * @param  string $domain (required)
     * @param  string $region (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestCheckdomainPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ComHivextApiResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function environmentBinderRestCheckdomainPostWithHttpInfo($domain, $region = null, string $contentType = self::contentTypes['environmentBinderRestCheckdomainPost'][0])
    {
        $request = $this->environmentBinderRestCheckdomainPostRequest($domain, $region, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ComHivextApiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ComHivextApiResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ComHivextApiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ComHivextApiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ComHivextApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation environmentBinderRestCheckdomainPostAsync
     *
     * @param  string $domain (required)
     * @param  string $region (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestCheckdomainPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestCheckdomainPostAsync($domain, $region = null, string $contentType = self::contentTypes['environmentBinderRestCheckdomainPost'][0])
    {
        return $this->environmentBinderRestCheckdomainPostAsyncWithHttpInfo($domain, $region, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation environmentBinderRestCheckdomainPostAsyncWithHttpInfo
     *
     * @param  string $domain (required)
     * @param  string $region (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestCheckdomainPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestCheckdomainPostAsyncWithHttpInfo($domain, $region = null, string $contentType = self::contentTypes['environmentBinderRestCheckdomainPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ComHivextApiResponse';
        $request = $this->environmentBinderRestCheckdomainPostRequest($domain, $region, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'environmentBinderRestCheckdomainPost'
     *
     * @param  string $domain (required)
     * @param  string $region (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestCheckdomainPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function environmentBinderRestCheckdomainPostRequest($domain, $region = null, string $contentType = self::contentTypes['environmentBinderRestCheckdomainPost'][0])
    {

        // verify the required parameter 'domain' is set
        if ($domain === null || (is_array($domain) && count($domain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain when calling environmentBinderRestCheckdomainPost'
            );
        }
        if (strlen($domain) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$domain" when calling BinderServiceApi.environmentBinderRestCheckdomainPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $domain)) {
            throw new \InvalidArgumentException("invalid value for \"domain\" when calling BinderServiceApi.environmentBinderRestCheckdomainPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        if ($region !== null && strlen($region) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$region" when calling BinderServiceApi.environmentBinderRestCheckdomainPost, must be smaller than or equal to 2147483647.');
        }
        if ($region !== null && !preg_match("/(.*){0,2147483647}/", $region)) {
            throw new \InvalidArgumentException("invalid value for \"region\" when calling BinderServiceApi.environmentBinderRestCheckdomainPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        

        $resourcePath = '/environment/binder/rest/checkdomain';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($domain !== null) {
            $formParams['domain'] = ObjectSerializer::toFormValue($domain);
        }
        // form params
        if ($region !== null) {
            $formParams['region'] = ObjectSerializer::toFormValue($region);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation environmentBinderRestCheckextdomainPost
     *
     * @param  string $extdomain extdomain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestCheckextdomainPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ComHivextApiResponse
     */
    public function environmentBinderRestCheckextdomainPost($extdomain, string $contentType = self::contentTypes['environmentBinderRestCheckextdomainPost'][0])
    {
        list($response) = $this->environmentBinderRestCheckextdomainPostWithHttpInfo($extdomain, $contentType);
        return $response;
    }

    /**
     * Operation environmentBinderRestCheckextdomainPostWithHttpInfo
     *
     * @param  string $extdomain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestCheckextdomainPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ComHivextApiResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function environmentBinderRestCheckextdomainPostWithHttpInfo($extdomain, string $contentType = self::contentTypes['environmentBinderRestCheckextdomainPost'][0])
    {
        $request = $this->environmentBinderRestCheckextdomainPostRequest($extdomain, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ComHivextApiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ComHivextApiResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ComHivextApiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ComHivextApiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ComHivextApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation environmentBinderRestCheckextdomainPostAsync
     *
     * @param  string $extdomain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestCheckextdomainPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestCheckextdomainPostAsync($extdomain, string $contentType = self::contentTypes['environmentBinderRestCheckextdomainPost'][0])
    {
        return $this->environmentBinderRestCheckextdomainPostAsyncWithHttpInfo($extdomain, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation environmentBinderRestCheckextdomainPostAsyncWithHttpInfo
     *
     * @param  string $extdomain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestCheckextdomainPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestCheckextdomainPostAsyncWithHttpInfo($extdomain, string $contentType = self::contentTypes['environmentBinderRestCheckextdomainPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ComHivextApiResponse';
        $request = $this->environmentBinderRestCheckextdomainPostRequest($extdomain, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'environmentBinderRestCheckextdomainPost'
     *
     * @param  string $extdomain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestCheckextdomainPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function environmentBinderRestCheckextdomainPostRequest($extdomain, string $contentType = self::contentTypes['environmentBinderRestCheckextdomainPost'][0])
    {

        // verify the required parameter 'extdomain' is set
        if ($extdomain === null || (is_array($extdomain) && count($extdomain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $extdomain when calling environmentBinderRestCheckextdomainPost'
            );
        }
        if (strlen($extdomain) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$extdomain" when calling BinderServiceApi.environmentBinderRestCheckextdomainPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $extdomain)) {
            throw new \InvalidArgumentException("invalid value for \"extdomain\" when calling BinderServiceApi.environmentBinderRestCheckextdomainPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        

        $resourcePath = '/environment/binder/rest/checkextdomain';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($extdomain !== null) {
            $formParams['extdomain'] = ObjectSerializer::toFormValue($extdomain);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation environmentBinderRestDeletesslPost
     *
     * @param  string $envName envName (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestDeletesslPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ComHivextApiResponse
     */
    public function environmentBinderRestDeletesslPost($envName, string $contentType = self::contentTypes['environmentBinderRestDeletesslPost'][0])
    {
        list($response) = $this->environmentBinderRestDeletesslPostWithHttpInfo($envName, $contentType);
        return $response;
    }

    /**
     * Operation environmentBinderRestDeletesslPostWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestDeletesslPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ComHivextApiResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function environmentBinderRestDeletesslPostWithHttpInfo($envName, string $contentType = self::contentTypes['environmentBinderRestDeletesslPost'][0])
    {
        $request = $this->environmentBinderRestDeletesslPostRequest($envName, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ComHivextApiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ComHivextApiResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ComHivextApiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ComHivextApiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ComHivextApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation environmentBinderRestDeletesslPostAsync
     *
     * @param  string $envName (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestDeletesslPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestDeletesslPostAsync($envName, string $contentType = self::contentTypes['environmentBinderRestDeletesslPost'][0])
    {
        return $this->environmentBinderRestDeletesslPostAsyncWithHttpInfo($envName, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation environmentBinderRestDeletesslPostAsyncWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestDeletesslPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestDeletesslPostAsyncWithHttpInfo($envName, string $contentType = self::contentTypes['environmentBinderRestDeletesslPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ComHivextApiResponse';
        $request = $this->environmentBinderRestDeletesslPostRequest($envName, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'environmentBinderRestDeletesslPost'
     *
     * @param  string $envName (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestDeletesslPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function environmentBinderRestDeletesslPostRequest($envName, string $contentType = self::contentTypes['environmentBinderRestDeletesslPost'][0])
    {

        // verify the required parameter 'envName' is set
        if ($envName === null || (is_array($envName) && count($envName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envName when calling environmentBinderRestDeletesslPost'
            );
        }
        if (strlen($envName) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$envName" when calling BinderServiceApi.environmentBinderRestDeletesslPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $envName)) {
            throw new \InvalidArgumentException("invalid value for \"envName\" when calling BinderServiceApi.environmentBinderRestDeletesslPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        

        $resourcePath = '/environment/binder/rest/deletessl';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($envName !== null) {
            $formParams['envName'] = ObjectSerializer::toFormValue($envName);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation environmentBinderRestDetachextipPost
     *
     * @param  string $envName envName (required)
     * @param  string $ip ip (required)
     * @param  int $nodeid nodeid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestDetachextipPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ComHivextApiResponse
     */
    public function environmentBinderRestDetachextipPost($envName, $ip, $nodeid, string $contentType = self::contentTypes['environmentBinderRestDetachextipPost'][0])
    {
        list($response) = $this->environmentBinderRestDetachextipPostWithHttpInfo($envName, $ip, $nodeid, $contentType);
        return $response;
    }

    /**
     * Operation environmentBinderRestDetachextipPostWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  string $ip (required)
     * @param  int $nodeid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestDetachextipPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ComHivextApiResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function environmentBinderRestDetachextipPostWithHttpInfo($envName, $ip, $nodeid, string $contentType = self::contentTypes['environmentBinderRestDetachextipPost'][0])
    {
        $request = $this->environmentBinderRestDetachextipPostRequest($envName, $ip, $nodeid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ComHivextApiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ComHivextApiResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ComHivextApiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ComHivextApiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ComHivextApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation environmentBinderRestDetachextipPostAsync
     *
     * @param  string $envName (required)
     * @param  string $ip (required)
     * @param  int $nodeid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestDetachextipPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestDetachextipPostAsync($envName, $ip, $nodeid, string $contentType = self::contentTypes['environmentBinderRestDetachextipPost'][0])
    {
        return $this->environmentBinderRestDetachextipPostAsyncWithHttpInfo($envName, $ip, $nodeid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation environmentBinderRestDetachextipPostAsyncWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  string $ip (required)
     * @param  int $nodeid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestDetachextipPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestDetachextipPostAsyncWithHttpInfo($envName, $ip, $nodeid, string $contentType = self::contentTypes['environmentBinderRestDetachextipPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ComHivextApiResponse';
        $request = $this->environmentBinderRestDetachextipPostRequest($envName, $ip, $nodeid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'environmentBinderRestDetachextipPost'
     *
     * @param  string $envName (required)
     * @param  string $ip (required)
     * @param  int $nodeid (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestDetachextipPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function environmentBinderRestDetachextipPostRequest($envName, $ip, $nodeid, string $contentType = self::contentTypes['environmentBinderRestDetachextipPost'][0])
    {

        // verify the required parameter 'envName' is set
        if ($envName === null || (is_array($envName) && count($envName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envName when calling environmentBinderRestDetachextipPost'
            );
        }
        if (strlen($envName) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$envName" when calling BinderServiceApi.environmentBinderRestDetachextipPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $envName)) {
            throw new \InvalidArgumentException("invalid value for \"envName\" when calling BinderServiceApi.environmentBinderRestDetachextipPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        // verify the required parameter 'ip' is set
        if ($ip === null || (is_array($ip) && count($ip) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ip when calling environmentBinderRestDetachextipPost'
            );
        }
        if (strlen($ip) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$ip" when calling BinderServiceApi.environmentBinderRestDetachextipPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $ip)) {
            throw new \InvalidArgumentException("invalid value for \"ip\" when calling BinderServiceApi.environmentBinderRestDetachextipPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        // verify the required parameter 'nodeid' is set
        if ($nodeid === null || (is_array($nodeid) && count($nodeid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $nodeid when calling environmentBinderRestDetachextipPost'
            );
        }
        if ($nodeid > 2147483647) {
            throw new \InvalidArgumentException('invalid value for "$nodeid" when calling BinderServiceApi.environmentBinderRestDetachextipPost, must be smaller than or equal to 2147483647.');
        }
        if ($nodeid < -2147483648) {
            throw new \InvalidArgumentException('invalid value for "$nodeid" when calling BinderServiceApi.environmentBinderRestDetachextipPost, must be bigger than or equal to -2147483648.');
        }
        

        $resourcePath = '/environment/binder/rest/detachextip';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($envName !== null) {
            $formParams['envName'] = ObjectSerializer::toFormValue($envName);
        }
        // form params
        if ($ip !== null) {
            $formParams['ip'] = ObjectSerializer::toFormValue($ip);
        }
        // form params
        if ($nodeid !== null) {
            $formParams['nodeid'] = ObjectSerializer::toFormValue($nodeid);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation environmentBinderRestDisablesslPost
     *
     * @param  string $envName envName (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestDisablesslPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ComHivextApiResponse
     */
    public function environmentBinderRestDisablesslPost($envName, string $contentType = self::contentTypes['environmentBinderRestDisablesslPost'][0])
    {
        list($response) = $this->environmentBinderRestDisablesslPostWithHttpInfo($envName, $contentType);
        return $response;
    }

    /**
     * Operation environmentBinderRestDisablesslPostWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestDisablesslPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ComHivextApiResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function environmentBinderRestDisablesslPostWithHttpInfo($envName, string $contentType = self::contentTypes['environmentBinderRestDisablesslPost'][0])
    {
        $request = $this->environmentBinderRestDisablesslPostRequest($envName, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ComHivextApiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ComHivextApiResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ComHivextApiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ComHivextApiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ComHivextApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation environmentBinderRestDisablesslPostAsync
     *
     * @param  string $envName (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestDisablesslPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestDisablesslPostAsync($envName, string $contentType = self::contentTypes['environmentBinderRestDisablesslPost'][0])
    {
        return $this->environmentBinderRestDisablesslPostAsyncWithHttpInfo($envName, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation environmentBinderRestDisablesslPostAsyncWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestDisablesslPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestDisablesslPostAsyncWithHttpInfo($envName, string $contentType = self::contentTypes['environmentBinderRestDisablesslPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ComHivextApiResponse';
        $request = $this->environmentBinderRestDisablesslPostRequest($envName, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'environmentBinderRestDisablesslPost'
     *
     * @param  string $envName (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestDisablesslPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function environmentBinderRestDisablesslPostRequest($envName, string $contentType = self::contentTypes['environmentBinderRestDisablesslPost'][0])
    {

        // verify the required parameter 'envName' is set
        if ($envName === null || (is_array($envName) && count($envName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envName when calling environmentBinderRestDisablesslPost'
            );
        }
        if (strlen($envName) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$envName" when calling BinderServiceApi.environmentBinderRestDisablesslPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $envName)) {
            throw new \InvalidArgumentException("invalid value for \"envName\" when calling BinderServiceApi.environmentBinderRestDisablesslPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        

        $resourcePath = '/environment/binder/rest/disablessl';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($envName !== null) {
            $formParams['envName'] = ObjectSerializer::toFormValue($envName);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation environmentBinderRestEditsslcertPost
     *
     * @param  int $id id (required)
     * @param  string $interm interm (optional)
     * @param  string $envName envName (optional)
     * @param  string $cert cert (optional)
     * @param  string $key key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestEditsslcertPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCertResponse
     */
    public function environmentBinderRestEditsslcertPost($id, $interm = null, $envName = null, $cert = null, $key = null, string $contentType = self::contentTypes['environmentBinderRestEditsslcertPost'][0])
    {
        list($response) = $this->environmentBinderRestEditsslcertPostWithHttpInfo($id, $interm, $envName, $cert, $key, $contentType);
        return $response;
    }

    /**
     * Operation environmentBinderRestEditsslcertPostWithHttpInfo
     *
     * @param  int $id (required)
     * @param  string $interm (optional)
     * @param  string $envName (optional)
     * @param  string $cert (optional)
     * @param  string $key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestEditsslcertPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCertResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function environmentBinderRestEditsslcertPostWithHttpInfo($id, $interm = null, $envName = null, $cert = null, $key = null, string $contentType = self::contentTypes['environmentBinderRestEditsslcertPost'][0])
    {
        $request = $this->environmentBinderRestEditsslcertPostRequest($id, $interm, $envName, $cert, $key, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCertResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCertResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCertResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCertResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCertResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation environmentBinderRestEditsslcertPostAsync
     *
     * @param  int $id (required)
     * @param  string $interm (optional)
     * @param  string $envName (optional)
     * @param  string $cert (optional)
     * @param  string $key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestEditsslcertPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestEditsslcertPostAsync($id, $interm = null, $envName = null, $cert = null, $key = null, string $contentType = self::contentTypes['environmentBinderRestEditsslcertPost'][0])
    {
        return $this->environmentBinderRestEditsslcertPostAsyncWithHttpInfo($id, $interm, $envName, $cert, $key, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation environmentBinderRestEditsslcertPostAsyncWithHttpInfo
     *
     * @param  int $id (required)
     * @param  string $interm (optional)
     * @param  string $envName (optional)
     * @param  string $cert (optional)
     * @param  string $key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestEditsslcertPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestEditsslcertPostAsyncWithHttpInfo($id, $interm = null, $envName = null, $cert = null, $key = null, string $contentType = self::contentTypes['environmentBinderRestEditsslcertPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCertResponse';
        $request = $this->environmentBinderRestEditsslcertPostRequest($id, $interm, $envName, $cert, $key, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'environmentBinderRestEditsslcertPost'
     *
     * @param  int $id (required)
     * @param  string $interm (optional)
     * @param  string $envName (optional)
     * @param  string $cert (optional)
     * @param  string $key (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestEditsslcertPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function environmentBinderRestEditsslcertPostRequest($id, $interm = null, $envName = null, $cert = null, $key = null, string $contentType = self::contentTypes['environmentBinderRestEditsslcertPost'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling environmentBinderRestEditsslcertPost'
            );
        }
        if ($id > 2147483647) {
            throw new \InvalidArgumentException('invalid value for "$id" when calling BinderServiceApi.environmentBinderRestEditsslcertPost, must be smaller than or equal to 2147483647.');
        }
        if ($id < -2147483648) {
            throw new \InvalidArgumentException('invalid value for "$id" when calling BinderServiceApi.environmentBinderRestEditsslcertPost, must be bigger than or equal to -2147483648.');
        }
        
        if ($interm !== null && strlen($interm) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$interm" when calling BinderServiceApi.environmentBinderRestEditsslcertPost, must be smaller than or equal to 2147483647.');
        }
        if ($interm !== null && !preg_match("/(.*){0,2147483647}/", $interm)) {
            throw new \InvalidArgumentException("invalid value for \"interm\" when calling BinderServiceApi.environmentBinderRestEditsslcertPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        if ($envName !== null && strlen($envName) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$envName" when calling BinderServiceApi.environmentBinderRestEditsslcertPost, must be smaller than or equal to 2147483647.');
        }
        if ($envName !== null && !preg_match("/(.*){0,2147483647}/", $envName)) {
            throw new \InvalidArgumentException("invalid value for \"envName\" when calling BinderServiceApi.environmentBinderRestEditsslcertPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        if ($cert !== null && strlen($cert) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$cert" when calling BinderServiceApi.environmentBinderRestEditsslcertPost, must be smaller than or equal to 2147483647.');
        }
        if ($cert !== null && !preg_match("/(.*){0,2147483647}/", $cert)) {
            throw new \InvalidArgumentException("invalid value for \"cert\" when calling BinderServiceApi.environmentBinderRestEditsslcertPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        if ($key !== null && strlen($key) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$key" when calling BinderServiceApi.environmentBinderRestEditsslcertPost, must be smaller than or equal to 2147483647.');
        }
        if ($key !== null && !preg_match("/(.*){0,2147483647}/", $key)) {
            throw new \InvalidArgumentException("invalid value for \"key\" when calling BinderServiceApi.environmentBinderRestEditsslcertPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        

        $resourcePath = '/environment/binder/rest/editsslcert';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($interm !== null) {
            $formParams['interm'] = ObjectSerializer::toFormValue($interm);
        }
        // form params
        if ($envName !== null) {
            $formParams['envName'] = ObjectSerializer::toFormValue($envName);
        }
        // form params
        if ($cert !== null) {
            $formParams['cert'] = ObjectSerializer::toFormValue($cert);
        }
        // form params
        if ($id !== null) {
            $formParams['id'] = ObjectSerializer::toFormValue($id);
        }
        // form params
        if ($key !== null) {
            $formParams['key'] = ObjectSerializer::toFormValue($key);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation environmentBinderRestGetdomainsPost
     *
     * @param  string $envName envName (required)
     * @param  bool $inShort inShort (optional)
     * @param  string $nodeGroup nodeGroup (optional)
     * @param  int $nodeId nodeId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestGetdomainsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseDomainsResponse
     */
    public function environmentBinderRestGetdomainsPost($envName, $inShort = null, $nodeGroup = null, $nodeId = null, string $contentType = self::contentTypes['environmentBinderRestGetdomainsPost'][0])
    {
        list($response) = $this->environmentBinderRestGetdomainsPostWithHttpInfo($envName, $inShort, $nodeGroup, $nodeId, $contentType);
        return $response;
    }

    /**
     * Operation environmentBinderRestGetdomainsPostWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  bool $inShort (optional)
     * @param  string $nodeGroup (optional)
     * @param  int $nodeId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestGetdomainsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseDomainsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function environmentBinderRestGetdomainsPostWithHttpInfo($envName, $inShort = null, $nodeGroup = null, $nodeId = null, string $contentType = self::contentTypes['environmentBinderRestGetdomainsPost'][0])
    {
        $request = $this->environmentBinderRestGetdomainsPostRequest($envName, $inShort, $nodeGroup, $nodeId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseDomainsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseDomainsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseDomainsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseDomainsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseDomainsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation environmentBinderRestGetdomainsPostAsync
     *
     * @param  string $envName (required)
     * @param  bool $inShort (optional)
     * @param  string $nodeGroup (optional)
     * @param  int $nodeId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestGetdomainsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestGetdomainsPostAsync($envName, $inShort = null, $nodeGroup = null, $nodeId = null, string $contentType = self::contentTypes['environmentBinderRestGetdomainsPost'][0])
    {
        return $this->environmentBinderRestGetdomainsPostAsyncWithHttpInfo($envName, $inShort, $nodeGroup, $nodeId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation environmentBinderRestGetdomainsPostAsyncWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  bool $inShort (optional)
     * @param  string $nodeGroup (optional)
     * @param  int $nodeId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestGetdomainsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestGetdomainsPostAsyncWithHttpInfo($envName, $inShort = null, $nodeGroup = null, $nodeId = null, string $contentType = self::contentTypes['environmentBinderRestGetdomainsPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseDomainsResponse';
        $request = $this->environmentBinderRestGetdomainsPostRequest($envName, $inShort, $nodeGroup, $nodeId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'environmentBinderRestGetdomainsPost'
     *
     * @param  string $envName (required)
     * @param  bool $inShort (optional)
     * @param  string $nodeGroup (optional)
     * @param  int $nodeId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestGetdomainsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function environmentBinderRestGetdomainsPostRequest($envName, $inShort = null, $nodeGroup = null, $nodeId = null, string $contentType = self::contentTypes['environmentBinderRestGetdomainsPost'][0])
    {

        // verify the required parameter 'envName' is set
        if ($envName === null || (is_array($envName) && count($envName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envName when calling environmentBinderRestGetdomainsPost'
            );
        }
        if (strlen($envName) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$envName" when calling BinderServiceApi.environmentBinderRestGetdomainsPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $envName)) {
            throw new \InvalidArgumentException("invalid value for \"envName\" when calling BinderServiceApi.environmentBinderRestGetdomainsPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        

        if ($nodeGroup !== null && strlen($nodeGroup) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$nodeGroup" when calling BinderServiceApi.environmentBinderRestGetdomainsPost, must be smaller than or equal to 2147483647.');
        }
        if ($nodeGroup !== null && !preg_match("/(.*){0,2147483647}/", $nodeGroup)) {
            throw new \InvalidArgumentException("invalid value for \"nodeGroup\" when calling BinderServiceApi.environmentBinderRestGetdomainsPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        if ($nodeId !== null && $nodeId > 2147483647) {
            throw new \InvalidArgumentException('invalid value for "$nodeId" when calling BinderServiceApi.environmentBinderRestGetdomainsPost, must be smaller than or equal to 2147483647.');
        }
        if ($nodeId !== null && $nodeId < -2147483648) {
            throw new \InvalidArgumentException('invalid value for "$nodeId" when calling BinderServiceApi.environmentBinderRestGetdomainsPost, must be bigger than or equal to -2147483648.');
        }
        

        $resourcePath = '/environment/binder/rest/getdomains';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($inShort !== null) {
            $formParams['inShort'] = ObjectSerializer::toFormValue($inShort);
        }
        // form params
        if ($envName !== null) {
            $formParams['envName'] = ObjectSerializer::toFormValue($envName);
        }
        // form params
        if ($nodeGroup !== null) {
            $formParams['nodeGroup'] = ObjectSerializer::toFormValue($nodeGroup);
        }
        // form params
        if ($nodeId !== null) {
            $formParams['nodeId'] = ObjectSerializer::toFormValue($nodeId);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation environmentBinderRestGetextdomainsPost
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestGetextdomainsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseExtDomainResponses
     */
    public function environmentBinderRestGetextdomainsPost(string $contentType = self::contentTypes['environmentBinderRestGetextdomainsPost'][0])
    {
        list($response) = $this->environmentBinderRestGetextdomainsPostWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation environmentBinderRestGetextdomainsPostWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestGetextdomainsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseExtDomainResponses, HTTP status code, HTTP response headers (array of strings)
     */
    public function environmentBinderRestGetextdomainsPostWithHttpInfo(string $contentType = self::contentTypes['environmentBinderRestGetextdomainsPost'][0])
    {
        $request = $this->environmentBinderRestGetextdomainsPostRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseExtDomainResponses' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseExtDomainResponses' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseExtDomainResponses', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseExtDomainResponses';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseExtDomainResponses',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation environmentBinderRestGetextdomainsPostAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestGetextdomainsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestGetextdomainsPostAsync(string $contentType = self::contentTypes['environmentBinderRestGetextdomainsPost'][0])
    {
        return $this->environmentBinderRestGetextdomainsPostAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation environmentBinderRestGetextdomainsPostAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestGetextdomainsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestGetextdomainsPostAsyncWithHttpInfo(string $contentType = self::contentTypes['environmentBinderRestGetextdomainsPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseExtDomainResponses';
        $request = $this->environmentBinderRestGetextdomainsPostRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'environmentBinderRestGetextdomainsPost'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestGetextdomainsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function environmentBinderRestGetextdomainsPostRequest(string $contentType = self::contentTypes['environmentBinderRestGetextdomainsPost'][0])
    {


        $resourcePath = '/environment/binder/rest/getextdomains';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation environmentBinderRestGetsslPost
     *
     * @param  string $envName envName (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestGetsslPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCustomResponse
     */
    public function environmentBinderRestGetsslPost($envName, string $contentType = self::contentTypes['environmentBinderRestGetsslPost'][0])
    {
        list($response) = $this->environmentBinderRestGetsslPostWithHttpInfo($envName, $contentType);
        return $response;
    }

    /**
     * Operation environmentBinderRestGetsslPostWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestGetsslPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCustomResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function environmentBinderRestGetsslPostWithHttpInfo($envName, string $contentType = self::contentTypes['environmentBinderRestGetsslPost'][0])
    {
        $request = $this->environmentBinderRestGetsslPostRequest($envName, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCustomResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCustomResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCustomResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCustomResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCustomResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation environmentBinderRestGetsslPostAsync
     *
     * @param  string $envName (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestGetsslPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestGetsslPostAsync($envName, string $contentType = self::contentTypes['environmentBinderRestGetsslPost'][0])
    {
        return $this->environmentBinderRestGetsslPostAsyncWithHttpInfo($envName, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation environmentBinderRestGetsslPostAsyncWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestGetsslPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestGetsslPostAsyncWithHttpInfo($envName, string $contentType = self::contentTypes['environmentBinderRestGetsslPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCustomResponse';
        $request = $this->environmentBinderRestGetsslPostRequest($envName, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'environmentBinderRestGetsslPost'
     *
     * @param  string $envName (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestGetsslPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function environmentBinderRestGetsslPostRequest($envName, string $contentType = self::contentTypes['environmentBinderRestGetsslPost'][0])
    {

        // verify the required parameter 'envName' is set
        if ($envName === null || (is_array($envName) && count($envName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envName when calling environmentBinderRestGetsslPost'
            );
        }
        if (strlen($envName) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$envName" when calling BinderServiceApi.environmentBinderRestGetsslPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $envName)) {
            throw new \InvalidArgumentException("invalid value for \"envName\" when calling BinderServiceApi.environmentBinderRestGetsslPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        

        $resourcePath = '/environment/binder/rest/getssl';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($envName !== null) {
            $formParams['envName'] = ObjectSerializer::toFormValue($envName);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation environmentBinderRestGetsslcertsPost
     *
     * @param  string $envName envName (optional)
     * @param  string $ids ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestGetsslcertsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCertResponses
     */
    public function environmentBinderRestGetsslcertsPost($envName = null, $ids = null, string $contentType = self::contentTypes['environmentBinderRestGetsslcertsPost'][0])
    {
        list($response) = $this->environmentBinderRestGetsslcertsPostWithHttpInfo($envName, $ids, $contentType);
        return $response;
    }

    /**
     * Operation environmentBinderRestGetsslcertsPostWithHttpInfo
     *
     * @param  string $envName (optional)
     * @param  string $ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestGetsslcertsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCertResponses, HTTP status code, HTTP response headers (array of strings)
     */
    public function environmentBinderRestGetsslcertsPostWithHttpInfo($envName = null, $ids = null, string $contentType = self::contentTypes['environmentBinderRestGetsslcertsPost'][0])
    {
        $request = $this->environmentBinderRestGetsslcertsPostRequest($envName, $ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCertResponses' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCertResponses' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCertResponses', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCertResponses';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCertResponses',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation environmentBinderRestGetsslcertsPostAsync
     *
     * @param  string $envName (optional)
     * @param  string $ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestGetsslcertsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestGetsslcertsPostAsync($envName = null, $ids = null, string $contentType = self::contentTypes['environmentBinderRestGetsslcertsPost'][0])
    {
        return $this->environmentBinderRestGetsslcertsPostAsyncWithHttpInfo($envName, $ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation environmentBinderRestGetsslcertsPostAsyncWithHttpInfo
     *
     * @param  string $envName (optional)
     * @param  string $ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestGetsslcertsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestGetsslcertsPostAsyncWithHttpInfo($envName = null, $ids = null, string $contentType = self::contentTypes['environmentBinderRestGetsslcertsPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSSLCertResponses';
        $request = $this->environmentBinderRestGetsslcertsPostRequest($envName, $ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'environmentBinderRestGetsslcertsPost'
     *
     * @param  string $envName (optional)
     * @param  string $ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestGetsslcertsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function environmentBinderRestGetsslcertsPostRequest($envName = null, $ids = null, string $contentType = self::contentTypes['environmentBinderRestGetsslcertsPost'][0])
    {

        if ($envName !== null && strlen($envName) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$envName" when calling BinderServiceApi.environmentBinderRestGetsslcertsPost, must be smaller than or equal to 2147483647.');
        }
        if ($envName !== null && !preg_match("/(.*){0,2147483647}/", $envName)) {
            throw new \InvalidArgumentException("invalid value for \"envName\" when calling BinderServiceApi.environmentBinderRestGetsslcertsPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        if ($ids !== null && strlen($ids) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$ids" when calling BinderServiceApi.environmentBinderRestGetsslcertsPost, must be smaller than or equal to 2147483647.');
        }
        if ($ids !== null && !preg_match("/(.*){0,2147483647}/", $ids)) {
            throw new \InvalidArgumentException("invalid value for \"ids\" when calling BinderServiceApi.environmentBinderRestGetsslcertsPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        

        $resourcePath = '/environment/binder/rest/getsslcerts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($envName !== null) {
            $formParams['envName'] = ObjectSerializer::toFormValue($envName);
        }
        // form params
        if ($ids !== null) {
            $formParams['ids'] = ObjectSerializer::toFormValue($ids);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation environmentBinderRestMoveextipsPost
     *
     * @param  string $envName envName (required)
     * @param  int $sourceNodeId sourceNodeId (required)
     * @param  int $targetNodeId targetNodeId (required)
     * @param  string $ips ips (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestMoveextipsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSoftwareNodesListResponse
     */
    public function environmentBinderRestMoveextipsPost($envName, $sourceNodeId, $targetNodeId, $ips, string $contentType = self::contentTypes['environmentBinderRestMoveextipsPost'][0])
    {
        list($response) = $this->environmentBinderRestMoveextipsPostWithHttpInfo($envName, $sourceNodeId, $targetNodeId, $ips, $contentType);
        return $response;
    }

    /**
     * Operation environmentBinderRestMoveextipsPostWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  int $sourceNodeId (required)
     * @param  int $targetNodeId (required)
     * @param  string $ips (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestMoveextipsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSoftwareNodesListResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function environmentBinderRestMoveextipsPostWithHttpInfo($envName, $sourceNodeId, $targetNodeId, $ips, string $contentType = self::contentTypes['environmentBinderRestMoveextipsPost'][0])
    {
        $request = $this->environmentBinderRestMoveextipsPostRequest($envName, $sourceNodeId, $targetNodeId, $ips, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSoftwareNodesListResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSoftwareNodesListResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSoftwareNodesListResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSoftwareNodesListResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSoftwareNodesListResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation environmentBinderRestMoveextipsPostAsync
     *
     * @param  string $envName (required)
     * @param  int $sourceNodeId (required)
     * @param  int $targetNodeId (required)
     * @param  string $ips (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestMoveextipsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestMoveextipsPostAsync($envName, $sourceNodeId, $targetNodeId, $ips, string $contentType = self::contentTypes['environmentBinderRestMoveextipsPost'][0])
    {
        return $this->environmentBinderRestMoveextipsPostAsyncWithHttpInfo($envName, $sourceNodeId, $targetNodeId, $ips, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation environmentBinderRestMoveextipsPostAsyncWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  int $sourceNodeId (required)
     * @param  int $targetNodeId (required)
     * @param  string $ips (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestMoveextipsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestMoveextipsPostAsyncWithHttpInfo($envName, $sourceNodeId, $targetNodeId, $ips, string $contentType = self::contentTypes['environmentBinderRestMoveextipsPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSoftwareNodesListResponse';
        $request = $this->environmentBinderRestMoveextipsPostRequest($envName, $sourceNodeId, $targetNodeId, $ips, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'environmentBinderRestMoveextipsPost'
     *
     * @param  string $envName (required)
     * @param  int $sourceNodeId (required)
     * @param  int $targetNodeId (required)
     * @param  string $ips (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestMoveextipsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function environmentBinderRestMoveextipsPostRequest($envName, $sourceNodeId, $targetNodeId, $ips, string $contentType = self::contentTypes['environmentBinderRestMoveextipsPost'][0])
    {

        // verify the required parameter 'envName' is set
        if ($envName === null || (is_array($envName) && count($envName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envName when calling environmentBinderRestMoveextipsPost'
            );
        }
        if (strlen($envName) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$envName" when calling BinderServiceApi.environmentBinderRestMoveextipsPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $envName)) {
            throw new \InvalidArgumentException("invalid value for \"envName\" when calling BinderServiceApi.environmentBinderRestMoveextipsPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        // verify the required parameter 'sourceNodeId' is set
        if ($sourceNodeId === null || (is_array($sourceNodeId) && count($sourceNodeId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sourceNodeId when calling environmentBinderRestMoveextipsPost'
            );
        }
        if ($sourceNodeId > 2147483647) {
            throw new \InvalidArgumentException('invalid value for "$sourceNodeId" when calling BinderServiceApi.environmentBinderRestMoveextipsPost, must be smaller than or equal to 2147483647.');
        }
        if ($sourceNodeId < -2147483648) {
            throw new \InvalidArgumentException('invalid value for "$sourceNodeId" when calling BinderServiceApi.environmentBinderRestMoveextipsPost, must be bigger than or equal to -2147483648.');
        }
        
        // verify the required parameter 'targetNodeId' is set
        if ($targetNodeId === null || (is_array($targetNodeId) && count($targetNodeId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $targetNodeId when calling environmentBinderRestMoveextipsPost'
            );
        }
        if ($targetNodeId > 2147483647) {
            throw new \InvalidArgumentException('invalid value for "$targetNodeId" when calling BinderServiceApi.environmentBinderRestMoveextipsPost, must be smaller than or equal to 2147483647.');
        }
        if ($targetNodeId < -2147483648) {
            throw new \InvalidArgumentException('invalid value for "$targetNodeId" when calling BinderServiceApi.environmentBinderRestMoveextipsPost, must be bigger than or equal to -2147483648.');
        }
        
        // verify the required parameter 'ips' is set
        if ($ips === null || (is_array($ips) && count($ips) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ips when calling environmentBinderRestMoveextipsPost'
            );
        }
        if (strlen($ips) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$ips" when calling BinderServiceApi.environmentBinderRestMoveextipsPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $ips)) {
            throw new \InvalidArgumentException("invalid value for \"ips\" when calling BinderServiceApi.environmentBinderRestMoveextipsPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        

        $resourcePath = '/environment/binder/rest/moveextips';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($envName !== null) {
            $formParams['envName'] = ObjectSerializer::toFormValue($envName);
        }
        // form params
        if ($sourceNodeId !== null) {
            $formParams['sourceNodeId'] = ObjectSerializer::toFormValue($sourceNodeId);
        }
        // form params
        if ($targetNodeId !== null) {
            $formParams['targetNodeId'] = ObjectSerializer::toFormValue($targetNodeId);
        }
        // form params
        if ($ips !== null) {
            $formParams['ips'] = ObjectSerializer::toFormValue($ips);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation environmentBinderRestRemovedomainsPost
     *
     * @param  string $envName envName (required)
     * @param  string $domains domains (required)
     * @param  string $nodeGroup nodeGroup (optional)
     * @param  int $nodeId nodeId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestRemovedomainsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ComHivextApiResponse
     */
    public function environmentBinderRestRemovedomainsPost($envName, $domains, $nodeGroup = null, $nodeId = null, string $contentType = self::contentTypes['environmentBinderRestRemovedomainsPost'][0])
    {
        list($response) = $this->environmentBinderRestRemovedomainsPostWithHttpInfo($envName, $domains, $nodeGroup, $nodeId, $contentType);
        return $response;
    }

    /**
     * Operation environmentBinderRestRemovedomainsPostWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  string $domains (required)
     * @param  string $nodeGroup (optional)
     * @param  int $nodeId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestRemovedomainsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ComHivextApiResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function environmentBinderRestRemovedomainsPostWithHttpInfo($envName, $domains, $nodeGroup = null, $nodeId = null, string $contentType = self::contentTypes['environmentBinderRestRemovedomainsPost'][0])
    {
        $request = $this->environmentBinderRestRemovedomainsPostRequest($envName, $domains, $nodeGroup, $nodeId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ComHivextApiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ComHivextApiResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ComHivextApiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ComHivextApiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ComHivextApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation environmentBinderRestRemovedomainsPostAsync
     *
     * @param  string $envName (required)
     * @param  string $domains (required)
     * @param  string $nodeGroup (optional)
     * @param  int $nodeId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestRemovedomainsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestRemovedomainsPostAsync($envName, $domains, $nodeGroup = null, $nodeId = null, string $contentType = self::contentTypes['environmentBinderRestRemovedomainsPost'][0])
    {
        return $this->environmentBinderRestRemovedomainsPostAsyncWithHttpInfo($envName, $domains, $nodeGroup, $nodeId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation environmentBinderRestRemovedomainsPostAsyncWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  string $domains (required)
     * @param  string $nodeGroup (optional)
     * @param  int $nodeId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestRemovedomainsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestRemovedomainsPostAsyncWithHttpInfo($envName, $domains, $nodeGroup = null, $nodeId = null, string $contentType = self::contentTypes['environmentBinderRestRemovedomainsPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ComHivextApiResponse';
        $request = $this->environmentBinderRestRemovedomainsPostRequest($envName, $domains, $nodeGroup, $nodeId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'environmentBinderRestRemovedomainsPost'
     *
     * @param  string $envName (required)
     * @param  string $domains (required)
     * @param  string $nodeGroup (optional)
     * @param  int $nodeId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestRemovedomainsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function environmentBinderRestRemovedomainsPostRequest($envName, $domains, $nodeGroup = null, $nodeId = null, string $contentType = self::contentTypes['environmentBinderRestRemovedomainsPost'][0])
    {

        // verify the required parameter 'envName' is set
        if ($envName === null || (is_array($envName) && count($envName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envName when calling environmentBinderRestRemovedomainsPost'
            );
        }
        if (strlen($envName) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$envName" when calling BinderServiceApi.environmentBinderRestRemovedomainsPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $envName)) {
            throw new \InvalidArgumentException("invalid value for \"envName\" when calling BinderServiceApi.environmentBinderRestRemovedomainsPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        // verify the required parameter 'domains' is set
        if ($domains === null || (is_array($domains) && count($domains) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domains when calling environmentBinderRestRemovedomainsPost'
            );
        }
        if (strlen($domains) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$domains" when calling BinderServiceApi.environmentBinderRestRemovedomainsPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $domains)) {
            throw new \InvalidArgumentException("invalid value for \"domains\" when calling BinderServiceApi.environmentBinderRestRemovedomainsPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        if ($nodeGroup !== null && strlen($nodeGroup) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$nodeGroup" when calling BinderServiceApi.environmentBinderRestRemovedomainsPost, must be smaller than or equal to 2147483647.');
        }
        if ($nodeGroup !== null && !preg_match("/(.*){0,2147483647}/", $nodeGroup)) {
            throw new \InvalidArgumentException("invalid value for \"nodeGroup\" when calling BinderServiceApi.environmentBinderRestRemovedomainsPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        if ($nodeId !== null && $nodeId > 2147483647) {
            throw new \InvalidArgumentException('invalid value for "$nodeId" when calling BinderServiceApi.environmentBinderRestRemovedomainsPost, must be smaller than or equal to 2147483647.');
        }
        if ($nodeId !== null && $nodeId < -2147483648) {
            throw new \InvalidArgumentException('invalid value for "$nodeId" when calling BinderServiceApi.environmentBinderRestRemovedomainsPost, must be bigger than or equal to -2147483648.');
        }
        

        $resourcePath = '/environment/binder/rest/removedomains';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($envName !== null) {
            $formParams['envName'] = ObjectSerializer::toFormValue($envName);
        }
        // form params
        if ($domains !== null) {
            $formParams['domains'] = ObjectSerializer::toFormValue($domains);
        }
        // form params
        if ($nodeGroup !== null) {
            $formParams['nodeGroup'] = ObjectSerializer::toFormValue($nodeGroup);
        }
        // form params
        if ($nodeId !== null) {
            $formParams['nodeId'] = ObjectSerializer::toFormValue($nodeId);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation environmentBinderRestRemoveextdomainPost
     *
     * @param  string $envName envName (required)
     * @param  string $extdomain extdomain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestRemoveextdomainPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ComHivextApiResponse
     */
    public function environmentBinderRestRemoveextdomainPost($envName, $extdomain, string $contentType = self::contentTypes['environmentBinderRestRemoveextdomainPost'][0])
    {
        list($response) = $this->environmentBinderRestRemoveextdomainPostWithHttpInfo($envName, $extdomain, $contentType);
        return $response;
    }

    /**
     * Operation environmentBinderRestRemoveextdomainPostWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  string $extdomain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestRemoveextdomainPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ComHivextApiResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function environmentBinderRestRemoveextdomainPostWithHttpInfo($envName, $extdomain, string $contentType = self::contentTypes['environmentBinderRestRemoveextdomainPost'][0])
    {
        $request = $this->environmentBinderRestRemoveextdomainPostRequest($envName, $extdomain, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ComHivextApiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ComHivextApiResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ComHivextApiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ComHivextApiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ComHivextApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation environmentBinderRestRemoveextdomainPostAsync
     *
     * @param  string $envName (required)
     * @param  string $extdomain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestRemoveextdomainPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestRemoveextdomainPostAsync($envName, $extdomain, string $contentType = self::contentTypes['environmentBinderRestRemoveextdomainPost'][0])
    {
        return $this->environmentBinderRestRemoveextdomainPostAsyncWithHttpInfo($envName, $extdomain, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation environmentBinderRestRemoveextdomainPostAsyncWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  string $extdomain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestRemoveextdomainPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestRemoveextdomainPostAsyncWithHttpInfo($envName, $extdomain, string $contentType = self::contentTypes['environmentBinderRestRemoveextdomainPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ComHivextApiResponse';
        $request = $this->environmentBinderRestRemoveextdomainPostRequest($envName, $extdomain, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'environmentBinderRestRemoveextdomainPost'
     *
     * @param  string $envName (required)
     * @param  string $extdomain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestRemoveextdomainPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function environmentBinderRestRemoveextdomainPostRequest($envName, $extdomain, string $contentType = self::contentTypes['environmentBinderRestRemoveextdomainPost'][0])
    {

        // verify the required parameter 'envName' is set
        if ($envName === null || (is_array($envName) && count($envName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envName when calling environmentBinderRestRemoveextdomainPost'
            );
        }
        if (strlen($envName) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$envName" when calling BinderServiceApi.environmentBinderRestRemoveextdomainPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $envName)) {
            throw new \InvalidArgumentException("invalid value for \"envName\" when calling BinderServiceApi.environmentBinderRestRemoveextdomainPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        // verify the required parameter 'extdomain' is set
        if ($extdomain === null || (is_array($extdomain) && count($extdomain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $extdomain when calling environmentBinderRestRemoveextdomainPost'
            );
        }
        if (strlen($extdomain) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$extdomain" when calling BinderServiceApi.environmentBinderRestRemoveextdomainPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $extdomain)) {
            throw new \InvalidArgumentException("invalid value for \"extdomain\" when calling BinderServiceApi.environmentBinderRestRemoveextdomainPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        

        $resourcePath = '/environment/binder/rest/removeextdomain';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($envName !== null) {
            $formParams['envName'] = ObjectSerializer::toFormValue($envName);
        }
        // form params
        if ($extdomain !== null) {
            $formParams['extdomain'] = ObjectSerializer::toFormValue($extdomain);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation environmentBinderRestRemovesslPost
     *
     * @param  string $envName envName (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestRemovesslPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ComHivextApiResponse
     */
    public function environmentBinderRestRemovesslPost($envName, string $contentType = self::contentTypes['environmentBinderRestRemovesslPost'][0])
    {
        list($response) = $this->environmentBinderRestRemovesslPostWithHttpInfo($envName, $contentType);
        return $response;
    }

    /**
     * Operation environmentBinderRestRemovesslPostWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestRemovesslPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ComHivextApiResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function environmentBinderRestRemovesslPostWithHttpInfo($envName, string $contentType = self::contentTypes['environmentBinderRestRemovesslPost'][0])
    {
        $request = $this->environmentBinderRestRemovesslPostRequest($envName, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ComHivextApiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ComHivextApiResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ComHivextApiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ComHivextApiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ComHivextApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation environmentBinderRestRemovesslPostAsync
     *
     * @param  string $envName (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestRemovesslPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestRemovesslPostAsync($envName, string $contentType = self::contentTypes['environmentBinderRestRemovesslPost'][0])
    {
        return $this->environmentBinderRestRemovesslPostAsyncWithHttpInfo($envName, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation environmentBinderRestRemovesslPostAsyncWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestRemovesslPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestRemovesslPostAsyncWithHttpInfo($envName, string $contentType = self::contentTypes['environmentBinderRestRemovesslPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ComHivextApiResponse';
        $request = $this->environmentBinderRestRemovesslPostRequest($envName, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'environmentBinderRestRemovesslPost'
     *
     * @param  string $envName (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestRemovesslPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function environmentBinderRestRemovesslPostRequest($envName, string $contentType = self::contentTypes['environmentBinderRestRemovesslPost'][0])
    {

        // verify the required parameter 'envName' is set
        if ($envName === null || (is_array($envName) && count($envName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envName when calling environmentBinderRestRemovesslPost'
            );
        }
        if (strlen($envName) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$envName" when calling BinderServiceApi.environmentBinderRestRemovesslPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $envName)) {
            throw new \InvalidArgumentException("invalid value for \"envName\" when calling BinderServiceApi.environmentBinderRestRemovesslPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        

        $resourcePath = '/environment/binder/rest/removessl';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($envName !== null) {
            $formParams['envName'] = ObjectSerializer::toFormValue($envName);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation environmentBinderRestRemovesslcertsPost
     *
     * @param  string $ids ids (required)
     * @param  string $envName envName (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestRemovesslcertsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ComHivextApiResponse
     */
    public function environmentBinderRestRemovesslcertsPost($ids, $envName = null, string $contentType = self::contentTypes['environmentBinderRestRemovesslcertsPost'][0])
    {
        list($response) = $this->environmentBinderRestRemovesslcertsPostWithHttpInfo($ids, $envName, $contentType);
        return $response;
    }

    /**
     * Operation environmentBinderRestRemovesslcertsPostWithHttpInfo
     *
     * @param  string $ids (required)
     * @param  string $envName (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestRemovesslcertsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ComHivextApiResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function environmentBinderRestRemovesslcertsPostWithHttpInfo($ids, $envName = null, string $contentType = self::contentTypes['environmentBinderRestRemovesslcertsPost'][0])
    {
        $request = $this->environmentBinderRestRemovesslcertsPostRequest($ids, $envName, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ComHivextApiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ComHivextApiResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ComHivextApiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ComHivextApiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ComHivextApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation environmentBinderRestRemovesslcertsPostAsync
     *
     * @param  string $ids (required)
     * @param  string $envName (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestRemovesslcertsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestRemovesslcertsPostAsync($ids, $envName = null, string $contentType = self::contentTypes['environmentBinderRestRemovesslcertsPost'][0])
    {
        return $this->environmentBinderRestRemovesslcertsPostAsyncWithHttpInfo($ids, $envName, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation environmentBinderRestRemovesslcertsPostAsyncWithHttpInfo
     *
     * @param  string $ids (required)
     * @param  string $envName (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestRemovesslcertsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestRemovesslcertsPostAsyncWithHttpInfo($ids, $envName = null, string $contentType = self::contentTypes['environmentBinderRestRemovesslcertsPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ComHivextApiResponse';
        $request = $this->environmentBinderRestRemovesslcertsPostRequest($ids, $envName, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'environmentBinderRestRemovesslcertsPost'
     *
     * @param  string $ids (required)
     * @param  string $envName (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestRemovesslcertsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function environmentBinderRestRemovesslcertsPostRequest($ids, $envName = null, string $contentType = self::contentTypes['environmentBinderRestRemovesslcertsPost'][0])
    {

        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling environmentBinderRestRemovesslcertsPost'
            );
        }
        if (strlen($ids) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$ids" when calling BinderServiceApi.environmentBinderRestRemovesslcertsPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $ids)) {
            throw new \InvalidArgumentException("invalid value for \"ids\" when calling BinderServiceApi.environmentBinderRestRemovesslcertsPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        if ($envName !== null && strlen($envName) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$envName" when calling BinderServiceApi.environmentBinderRestRemovesslcertsPost, must be smaller than or equal to 2147483647.');
        }
        if ($envName !== null && !preg_match("/(.*){0,2147483647}/", $envName)) {
            throw new \InvalidArgumentException("invalid value for \"envName\" when calling BinderServiceApi.environmentBinderRestRemovesslcertsPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        

        $resourcePath = '/environment/binder/rest/removesslcerts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($envName !== null) {
            $formParams['envName'] = ObjectSerializer::toFormValue($envName);
        }
        // form params
        if ($ids !== null) {
            $formParams['ids'] = ObjectSerializer::toFormValue($ids);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation environmentBinderRestSetextipcountPost
     *
     * @param  string $envName envName (required)
     * @param  int $count count (required)
     * @param  string $type type (required)
     * @param  string $nodeGroup nodeGroup (optional)
     * @param  int $nodeId nodeId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestSetextipcountPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseArrayExtIPAddressResponse
     */
    public function environmentBinderRestSetextipcountPost($envName, $count, $type, $nodeGroup = null, $nodeId = null, string $contentType = self::contentTypes['environmentBinderRestSetextipcountPost'][0])
    {
        list($response) = $this->environmentBinderRestSetextipcountPostWithHttpInfo($envName, $count, $type, $nodeGroup, $nodeId, $contentType);
        return $response;
    }

    /**
     * Operation environmentBinderRestSetextipcountPostWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  int $count (required)
     * @param  string $type (required)
     * @param  string $nodeGroup (optional)
     * @param  int $nodeId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestSetextipcountPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseArrayExtIPAddressResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function environmentBinderRestSetextipcountPostWithHttpInfo($envName, $count, $type, $nodeGroup = null, $nodeId = null, string $contentType = self::contentTypes['environmentBinderRestSetextipcountPost'][0])
    {
        $request = $this->environmentBinderRestSetextipcountPostRequest($envName, $count, $type, $nodeGroup, $nodeId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseArrayExtIPAddressResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseArrayExtIPAddressResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseArrayExtIPAddressResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseArrayExtIPAddressResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseArrayExtIPAddressResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation environmentBinderRestSetextipcountPostAsync
     *
     * @param  string $envName (required)
     * @param  int $count (required)
     * @param  string $type (required)
     * @param  string $nodeGroup (optional)
     * @param  int $nodeId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestSetextipcountPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestSetextipcountPostAsync($envName, $count, $type, $nodeGroup = null, $nodeId = null, string $contentType = self::contentTypes['environmentBinderRestSetextipcountPost'][0])
    {
        return $this->environmentBinderRestSetextipcountPostAsyncWithHttpInfo($envName, $count, $type, $nodeGroup, $nodeId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation environmentBinderRestSetextipcountPostAsyncWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  int $count (required)
     * @param  string $type (required)
     * @param  string $nodeGroup (optional)
     * @param  int $nodeId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestSetextipcountPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestSetextipcountPostAsyncWithHttpInfo($envName, $count, $type, $nodeGroup = null, $nodeId = null, string $contentType = self::contentTypes['environmentBinderRestSetextipcountPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseArrayExtIPAddressResponse';
        $request = $this->environmentBinderRestSetextipcountPostRequest($envName, $count, $type, $nodeGroup, $nodeId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'environmentBinderRestSetextipcountPost'
     *
     * @param  string $envName (required)
     * @param  int $count (required)
     * @param  string $type (required)
     * @param  string $nodeGroup (optional)
     * @param  int $nodeId (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestSetextipcountPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function environmentBinderRestSetextipcountPostRequest($envName, $count, $type, $nodeGroup = null, $nodeId = null, string $contentType = self::contentTypes['environmentBinderRestSetextipcountPost'][0])
    {

        // verify the required parameter 'envName' is set
        if ($envName === null || (is_array($envName) && count($envName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envName when calling environmentBinderRestSetextipcountPost'
            );
        }
        if (strlen($envName) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$envName" when calling BinderServiceApi.environmentBinderRestSetextipcountPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $envName)) {
            throw new \InvalidArgumentException("invalid value for \"envName\" when calling BinderServiceApi.environmentBinderRestSetextipcountPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        // verify the required parameter 'count' is set
        if ($count === null || (is_array($count) && count($count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $count when calling environmentBinderRestSetextipcountPost'
            );
        }
        if ($count > 2147483647) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling BinderServiceApi.environmentBinderRestSetextipcountPost, must be smaller than or equal to 2147483647.');
        }
        if ($count < -2147483648) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling BinderServiceApi.environmentBinderRestSetextipcountPost, must be bigger than or equal to -2147483648.');
        }
        
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling environmentBinderRestSetextipcountPost'
            );
        }
        if (strlen($type) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$type" when calling BinderServiceApi.environmentBinderRestSetextipcountPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $type)) {
            throw new \InvalidArgumentException("invalid value for \"type\" when calling BinderServiceApi.environmentBinderRestSetextipcountPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        if ($nodeGroup !== null && strlen($nodeGroup) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$nodeGroup" when calling BinderServiceApi.environmentBinderRestSetextipcountPost, must be smaller than or equal to 2147483647.');
        }
        if ($nodeGroup !== null && !preg_match("/(.*){0,2147483647}/", $nodeGroup)) {
            throw new \InvalidArgumentException("invalid value for \"nodeGroup\" when calling BinderServiceApi.environmentBinderRestSetextipcountPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        if ($nodeId !== null && $nodeId > 2147483647) {
            throw new \InvalidArgumentException('invalid value for "$nodeId" when calling BinderServiceApi.environmentBinderRestSetextipcountPost, must be smaller than or equal to 2147483647.');
        }
        if ($nodeId !== null && $nodeId < -2147483648) {
            throw new \InvalidArgumentException('invalid value for "$nodeId" when calling BinderServiceApi.environmentBinderRestSetextipcountPost, must be bigger than or equal to -2147483648.');
        }
        

        $resourcePath = '/environment/binder/rest/setextipcount';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($envName !== null) {
            $formParams['envName'] = ObjectSerializer::toFormValue($envName);
        }
        // form params
        if ($count !== null) {
            $formParams['count'] = ObjectSerializer::toFormValue($count);
        }
        // form params
        if ($type !== null) {
            $formParams['type'] = ObjectSerializer::toFormValue($type);
        }
        // form params
        if ($nodeGroup !== null) {
            $formParams['nodeGroup'] = ObjectSerializer::toFormValue($nodeGroup);
        }
        // form params
        if ($nodeId !== null) {
            $formParams['nodeId'] = ObjectSerializer::toFormValue($nodeId);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation environmentBinderRestSwapextdomainsPost
     *
     * @param  string $targetappid targetappid (required)
     * @param  string $envName envName (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestSwapextdomainsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ComHivextApiResponse
     */
    public function environmentBinderRestSwapextdomainsPost($targetappid, $envName, string $contentType = self::contentTypes['environmentBinderRestSwapextdomainsPost'][0])
    {
        list($response) = $this->environmentBinderRestSwapextdomainsPostWithHttpInfo($targetappid, $envName, $contentType);
        return $response;
    }

    /**
     * Operation environmentBinderRestSwapextdomainsPostWithHttpInfo
     *
     * @param  string $targetappid (required)
     * @param  string $envName (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestSwapextdomainsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ComHivextApiResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function environmentBinderRestSwapextdomainsPostWithHttpInfo($targetappid, $envName, string $contentType = self::contentTypes['environmentBinderRestSwapextdomainsPost'][0])
    {
        $request = $this->environmentBinderRestSwapextdomainsPostRequest($targetappid, $envName, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ComHivextApiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ComHivextApiResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ComHivextApiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ComHivextApiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ComHivextApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation environmentBinderRestSwapextdomainsPostAsync
     *
     * @param  string $targetappid (required)
     * @param  string $envName (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestSwapextdomainsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestSwapextdomainsPostAsync($targetappid, $envName, string $contentType = self::contentTypes['environmentBinderRestSwapextdomainsPost'][0])
    {
        return $this->environmentBinderRestSwapextdomainsPostAsyncWithHttpInfo($targetappid, $envName, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation environmentBinderRestSwapextdomainsPostAsyncWithHttpInfo
     *
     * @param  string $targetappid (required)
     * @param  string $envName (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestSwapextdomainsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestSwapextdomainsPostAsyncWithHttpInfo($targetappid, $envName, string $contentType = self::contentTypes['environmentBinderRestSwapextdomainsPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ComHivextApiResponse';
        $request = $this->environmentBinderRestSwapextdomainsPostRequest($targetappid, $envName, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'environmentBinderRestSwapextdomainsPost'
     *
     * @param  string $targetappid (required)
     * @param  string $envName (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestSwapextdomainsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function environmentBinderRestSwapextdomainsPostRequest($targetappid, $envName, string $contentType = self::contentTypes['environmentBinderRestSwapextdomainsPost'][0])
    {

        // verify the required parameter 'targetappid' is set
        if ($targetappid === null || (is_array($targetappid) && count($targetappid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $targetappid when calling environmentBinderRestSwapextdomainsPost'
            );
        }
        if (strlen($targetappid) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$targetappid" when calling BinderServiceApi.environmentBinderRestSwapextdomainsPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $targetappid)) {
            throw new \InvalidArgumentException("invalid value for \"targetappid\" when calling BinderServiceApi.environmentBinderRestSwapextdomainsPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        // verify the required parameter 'envName' is set
        if ($envName === null || (is_array($envName) && count($envName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envName when calling environmentBinderRestSwapextdomainsPost'
            );
        }
        if (strlen($envName) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$envName" when calling BinderServiceApi.environmentBinderRestSwapextdomainsPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $envName)) {
            throw new \InvalidArgumentException("invalid value for \"envName\" when calling BinderServiceApi.environmentBinderRestSwapextdomainsPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        

        $resourcePath = '/environment/binder/rest/swapextdomains';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($targetappid !== null) {
            $formParams['targetappid'] = ObjectSerializer::toFormValue($targetappid);
        }
        // form params
        if ($envName !== null) {
            $formParams['envName'] = ObjectSerializer::toFormValue($envName);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation environmentBinderRestSwapextipsPost
     *
     * @param  string $envName envName (required)
     * @param  int $sourceNodeId sourceNodeId (required)
     * @param  int $targetNodeId targetNodeId (required)
     * @param  string $targetIp targetIp (optional)
     * @param  string $sourceIp sourceIp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestSwapextipsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSoftwareNodesListResponse
     */
    public function environmentBinderRestSwapextipsPost($envName, $sourceNodeId, $targetNodeId, $targetIp = null, $sourceIp = null, string $contentType = self::contentTypes['environmentBinderRestSwapextipsPost'][0])
    {
        list($response) = $this->environmentBinderRestSwapextipsPostWithHttpInfo($envName, $sourceNodeId, $targetNodeId, $targetIp, $sourceIp, $contentType);
        return $response;
    }

    /**
     * Operation environmentBinderRestSwapextipsPostWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  int $sourceNodeId (required)
     * @param  int $targetNodeId (required)
     * @param  string $targetIp (optional)
     * @param  string $sourceIp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestSwapextipsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSoftwareNodesListResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function environmentBinderRestSwapextipsPostWithHttpInfo($envName, $sourceNodeId, $targetNodeId, $targetIp = null, $sourceIp = null, string $contentType = self::contentTypes['environmentBinderRestSwapextipsPost'][0])
    {
        $request = $this->environmentBinderRestSwapextipsPostRequest($envName, $sourceNodeId, $targetNodeId, $targetIp, $sourceIp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSoftwareNodesListResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSoftwareNodesListResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSoftwareNodesListResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSoftwareNodesListResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSoftwareNodesListResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation environmentBinderRestSwapextipsPostAsync
     *
     * @param  string $envName (required)
     * @param  int $sourceNodeId (required)
     * @param  int $targetNodeId (required)
     * @param  string $targetIp (optional)
     * @param  string $sourceIp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestSwapextipsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestSwapextipsPostAsync($envName, $sourceNodeId, $targetNodeId, $targetIp = null, $sourceIp = null, string $contentType = self::contentTypes['environmentBinderRestSwapextipsPost'][0])
    {
        return $this->environmentBinderRestSwapextipsPostAsyncWithHttpInfo($envName, $sourceNodeId, $targetNodeId, $targetIp, $sourceIp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation environmentBinderRestSwapextipsPostAsyncWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  int $sourceNodeId (required)
     * @param  int $targetNodeId (required)
     * @param  string $targetIp (optional)
     * @param  string $sourceIp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestSwapextipsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestSwapextipsPostAsyncWithHttpInfo($envName, $sourceNodeId, $targetNodeId, $targetIp = null, $sourceIp = null, string $contentType = self::contentTypes['environmentBinderRestSwapextipsPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ComHivextApiServerEnvironmentResponseSoftwareNodesListResponse';
        $request = $this->environmentBinderRestSwapextipsPostRequest($envName, $sourceNodeId, $targetNodeId, $targetIp, $sourceIp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'environmentBinderRestSwapextipsPost'
     *
     * @param  string $envName (required)
     * @param  int $sourceNodeId (required)
     * @param  int $targetNodeId (required)
     * @param  string $targetIp (optional)
     * @param  string $sourceIp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestSwapextipsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function environmentBinderRestSwapextipsPostRequest($envName, $sourceNodeId, $targetNodeId, $targetIp = null, $sourceIp = null, string $contentType = self::contentTypes['environmentBinderRestSwapextipsPost'][0])
    {

        // verify the required parameter 'envName' is set
        if ($envName === null || (is_array($envName) && count($envName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envName when calling environmentBinderRestSwapextipsPost'
            );
        }
        if (strlen($envName) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$envName" when calling BinderServiceApi.environmentBinderRestSwapextipsPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $envName)) {
            throw new \InvalidArgumentException("invalid value for \"envName\" when calling BinderServiceApi.environmentBinderRestSwapextipsPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        // verify the required parameter 'sourceNodeId' is set
        if ($sourceNodeId === null || (is_array($sourceNodeId) && count($sourceNodeId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sourceNodeId when calling environmentBinderRestSwapextipsPost'
            );
        }
        if ($sourceNodeId > 2147483647) {
            throw new \InvalidArgumentException('invalid value for "$sourceNodeId" when calling BinderServiceApi.environmentBinderRestSwapextipsPost, must be smaller than or equal to 2147483647.');
        }
        if ($sourceNodeId < -2147483648) {
            throw new \InvalidArgumentException('invalid value for "$sourceNodeId" when calling BinderServiceApi.environmentBinderRestSwapextipsPost, must be bigger than or equal to -2147483648.');
        }
        
        // verify the required parameter 'targetNodeId' is set
        if ($targetNodeId === null || (is_array($targetNodeId) && count($targetNodeId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $targetNodeId when calling environmentBinderRestSwapextipsPost'
            );
        }
        if ($targetNodeId > 2147483647) {
            throw new \InvalidArgumentException('invalid value for "$targetNodeId" when calling BinderServiceApi.environmentBinderRestSwapextipsPost, must be smaller than or equal to 2147483647.');
        }
        if ($targetNodeId < -2147483648) {
            throw new \InvalidArgumentException('invalid value for "$targetNodeId" when calling BinderServiceApi.environmentBinderRestSwapextipsPost, must be bigger than or equal to -2147483648.');
        }
        
        if ($targetIp !== null && strlen($targetIp) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$targetIp" when calling BinderServiceApi.environmentBinderRestSwapextipsPost, must be smaller than or equal to 2147483647.');
        }
        if ($targetIp !== null && !preg_match("/(.*){0,2147483647}/", $targetIp)) {
            throw new \InvalidArgumentException("invalid value for \"targetIp\" when calling BinderServiceApi.environmentBinderRestSwapextipsPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        if ($sourceIp !== null && strlen($sourceIp) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$sourceIp" when calling BinderServiceApi.environmentBinderRestSwapextipsPost, must be smaller than or equal to 2147483647.');
        }
        if ($sourceIp !== null && !preg_match("/(.*){0,2147483647}/", $sourceIp)) {
            throw new \InvalidArgumentException("invalid value for \"sourceIp\" when calling BinderServiceApi.environmentBinderRestSwapextipsPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        

        $resourcePath = '/environment/binder/rest/swapextips';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($targetIp !== null) {
            $formParams['targetIp'] = ObjectSerializer::toFormValue($targetIp);
        }
        // form params
        if ($sourceIp !== null) {
            $formParams['sourceIp'] = ObjectSerializer::toFormValue($sourceIp);
        }
        // form params
        if ($envName !== null) {
            $formParams['envName'] = ObjectSerializer::toFormValue($envName);
        }
        // form params
        if ($sourceNodeId !== null) {
            $formParams['sourceNodeId'] = ObjectSerializer::toFormValue($sourceNodeId);
        }
        // form params
        if ($targetNodeId !== null) {
            $formParams['targetNodeId'] = ObjectSerializer::toFormValue($targetNodeId);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation environmentBinderRestUnbindsslcertPost
     *
     * @param  string $envName envName (required)
     * @param  string $extDomains extDomains (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestUnbindsslcertPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ComHivextApiResponse
     */
    public function environmentBinderRestUnbindsslcertPost($envName, $extDomains = null, string $contentType = self::contentTypes['environmentBinderRestUnbindsslcertPost'][0])
    {
        list($response) = $this->environmentBinderRestUnbindsslcertPostWithHttpInfo($envName, $extDomains, $contentType);
        return $response;
    }

    /**
     * Operation environmentBinderRestUnbindsslcertPostWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  string $extDomains (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestUnbindsslcertPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ComHivextApiResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function environmentBinderRestUnbindsslcertPostWithHttpInfo($envName, $extDomains = null, string $contentType = self::contentTypes['environmentBinderRestUnbindsslcertPost'][0])
    {
        $request = $this->environmentBinderRestUnbindsslcertPostRequest($envName, $extDomains, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ComHivextApiResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ComHivextApiResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ComHivextApiResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ComHivextApiResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ComHivextApiResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation environmentBinderRestUnbindsslcertPostAsync
     *
     * @param  string $envName (required)
     * @param  string $extDomains (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestUnbindsslcertPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestUnbindsslcertPostAsync($envName, $extDomains = null, string $contentType = self::contentTypes['environmentBinderRestUnbindsslcertPost'][0])
    {
        return $this->environmentBinderRestUnbindsslcertPostAsyncWithHttpInfo($envName, $extDomains, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation environmentBinderRestUnbindsslcertPostAsyncWithHttpInfo
     *
     * @param  string $envName (required)
     * @param  string $extDomains (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestUnbindsslcertPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function environmentBinderRestUnbindsslcertPostAsyncWithHttpInfo($envName, $extDomains = null, string $contentType = self::contentTypes['environmentBinderRestUnbindsslcertPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ComHivextApiResponse';
        $request = $this->environmentBinderRestUnbindsslcertPostRequest($envName, $extDomains, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'environmentBinderRestUnbindsslcertPost'
     *
     * @param  string $envName (required)
     * @param  string $extDomains (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['environmentBinderRestUnbindsslcertPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function environmentBinderRestUnbindsslcertPostRequest($envName, $extDomains = null, string $contentType = self::contentTypes['environmentBinderRestUnbindsslcertPost'][0])
    {

        // verify the required parameter 'envName' is set
        if ($envName === null || (is_array($envName) && count($envName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $envName when calling environmentBinderRestUnbindsslcertPost'
            );
        }
        if (strlen($envName) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$envName" when calling BinderServiceApi.environmentBinderRestUnbindsslcertPost, must be smaller than or equal to 2147483647.');
        }
        if (!preg_match("/(.*){0,2147483647}/", $envName)) {
            throw new \InvalidArgumentException("invalid value for \"envName\" when calling BinderServiceApi.environmentBinderRestUnbindsslcertPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        
        if ($extDomains !== null && strlen($extDomains) > 2147483647) {
            throw new \InvalidArgumentException('invalid length for "$extDomains" when calling BinderServiceApi.environmentBinderRestUnbindsslcertPost, must be smaller than or equal to 2147483647.');
        }
        if ($extDomains !== null && !preg_match("/(.*){0,2147483647}/", $extDomains)) {
            throw new \InvalidArgumentException("invalid value for \"extDomains\" when calling BinderServiceApi.environmentBinderRestUnbindsslcertPost, must conform to the pattern /(.*){0,2147483647}/.");
        }
        

        $resourcePath = '/environment/binder/rest/unbindsslcert';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($envName !== null) {
            $formParams['envName'] = ObjectSerializer::toFormValue($envName);
        }
        // form params
        if ($extDomains !== null) {
            $formParams['extDomains'] = ObjectSerializer::toFormValue($extDomains);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
